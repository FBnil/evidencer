#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
Getopt::Long::Configure("bundling");
use Pod::Usage;
use File::Basename qw(dirname basename fileparse fileparse_set_fstype);
use Cwd 'abs_path';
use feature 'say';

my $CFGFILE;
my %DEFER;    # for GROUP or (UN)FOLD
my %RICH;     # for forcing a new servergroup file
my %CFG;
my %BASECFG = (
	PID       => $$,
	N         => 0,
	UTC       => 0,
	NEWLINE   => "\n",
	SEPARATOR => "  ",
	ARG       => "",
	QUOTESTR  => "'"
);
my $SUIT = $ENV{'SUIT'} || "";

my %opt;
my ( $opt_help, $opt_man );

# Before GetOptions, check if we have a -- and grab the arguments into %{ARG}
if ( grep /^\-\-$/, @ARGV ) {
	@_ = ();
	while ( ( $_ = pop @ARGV ) ne '--' ) {
		unshift @_, $_;
	}
	$BASECFG{ARG} = join " ", @_;
}

GetOptions(
	'help|h|?!'     => \$opt_help,
	'man!'          => \$opt_man,
	'config|c=s'    => \$CFGFILE,
	'DEBUG|D'       => \$BASECFG{DEBUG},
	'verbose|v'     => \$BASECFG{VERBOSE},
	'dryrun|d'      => \$BASECFG{DRYRUN},
	'UTC|U'         => \$BASECFG{UTC},
	'CREATEDIRS|C'  => \$BASECFG{CREATEDIRS},
	'keep|k'        => \$BASECFG{KEEP},
	'noautofix|n'   => \$BASECFG{NOAUTOFIX},
	'unfold|u'      => \$BASECFG{UNFOLD},
	'fold|f'        => \$BASECFG{FOLD},
	'group|g'       => \$BASECFG{GROUP},
	'bundle|b'      => \$BASECFG{BUNDLE},
	'redefine|r=s@' => \$BASECFG{REDEFINE},
	'suit|s:s'      => \$SUIT,
	'SEPARATOR|S:s' => \$BASECFG{SEPARATOR},
	'argument|a:s'  => \$BASECFG{ARG},
	'quote|q'       => \$BASECFG{QUOTE},
	'test|t:s'      => \$BASECFG{TEST},
) or pod2usage( -verbose => 0 );

# Do not override these from configuration file if set from the commandline through params
my %DONOTOVERRIDE = map { $_ => 1 } qw(DEBUG VERBOSE DRYRUN CREATEDIRS FORCE);

pod2usage( -verbose => 1 ) if defined $opt_help;
pod2usage( -verbose => 2 ) if defined $opt_man;

# Make sure at least one argument provided
if ( !@ARGV && !$BASECFG{'CREATEDIRS'} ) {
	pod2usage( -verbose => 0, -message => "$0: one argument required" );
}

# Read configuration file
sub readCFG
{
	my ( $NEWCFG, $NEWSUIT ) = @_;
	$NEWCFG  = $NEWCFG  || '';
	$NEWSUIT = $NEWSUIT || '';
	my $me      = abs_path( dirname($0) ) . '/' . basename($0);
	my $BASEDIR = dirname $me;
	%CFG = (
		%BASECFG,
		(
			'BASEDIR'        => $BASEDIR,
			'TEMP'           => $BASEDIR . "/tmp",
			'SUITDIR'        => $BASEDIR . "/suits",
			'SUIT'           => '..',
			'SERVERS'        => 'servers',
			'SCRIPTS'        => 'scripts',
			'RESULTS'        => 'results',
			'_SELECTED_SUIT' => $NEWSUIT || '..',
		)
	);
	updateTime( \%CFG );    # cfgfile might need the variables.
	my ( $name, $path, $suffix ) = fileparse( $me, '.pl' );
	my $_CFGFILE =
	  $NEWCFG
	  || ($NEWSUIT
		? $CFG{'SUITDIR'} . '/' . $NEWSUIT . '/' . $name . '.cfg'
		: $path . $name . '.cfg' );
		 -f $_CFGFILE
	  || -f ( $_CFGFILE = $path . $name . '.cfg' )
	  || -f ( $_CFGFILE = $path . 'cfg/' . $name . '.cfg' )
	  || -f ( $_CFGFILE = $path . '../cfg/' . $name . '.cfg' );

	if ( -f $_CFGFILE ) {
		$CFG{'CFGFILE'} = $_CFGFILE;
		say "readCFG($NEWCFG,$NEWSUIT)=$_CFGFILE" if $BASECFG{'VERBOSE'};
		open( my $CFG, '<', $_CFGFILE ) or abort("$_CFGFILE $!");
		my %DIRS = map { $_ => 1 } qw(TEMP);
		while (<$CFG>) {
			next if /^#/ || !/=/;
			chomp;
			s/\s+$//;
			if (/^ALIAS\s+([^=]+)\s*=\s*(.*)\s*/) {
				$CFG{'ALIAS'}{$1} = $2;
			} else {
				my ( $k, $v ) = split '=', $_, 2;
				$v = xexpand( $v, '%\{(\w+)\}', \%CFG ) if index( $v, "%{" ) > -1;
				$v = abs_path($v) if $DIRS{$k};
				$CFG{$k} = $v unless $DONOTOVERRIDE{$k} && defined $CFG{$k};
			}
		}
	}
	for my $k (qw(SUIT)) {
		$CFG{$k} = $ENV{$k} if defined $ENV{$k};
	}
	if ( $CFG{REDEFINE} ) {
		for my $redef ( @{ $CFG{REDEFINE} } ) {
			if ( index( $redef, "=" ) == -1 ) {
				if ( index( $redef, "," ) > -1 ) {
					push @{ $CFG{REDEFINE} }, split /,/, $redef;
					next;
				}
				$redef =~ s/\b$_\b/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
			}
			@_ = split "=", $redef, 2;
			say "# redef=($redef)" if $CFG{'DEBUG'};
			if ( index( $_[1], "%{" ) > -1 ) {
				xexpand( $_[1], '%\{(\w+)\}', \%CFG );
			}
			$CFG{ $_[0] } = $_[1];
		}
	}
}

readCFG( $CFGFILE, $SUIT );
say "BASEDIR=$CFG{'BASEDIR'} CFGFILE=$CFG{'CFGFILE'}" if $CFG{'DEBUG'};

sub md
{
	if ( !-d $_[0] ) {
		say "mkdir $_[0]";
		mkdir $_[0];
		return 1;
	} elsif ( $CFG{'VERBOSE'} || $CFG{'DEBUG'} ) {
		say "#Directory already exists: $_[0]";
		return 0;
	}
}

if ( $CFG{'CREATEDIRS'} ) {
	$SUIT = $SUIT || $CFG{'SUIT'};
	my $c = 0;
	$c += !!md( $CFG{$_} )                                       for (qw(TEMP SUITDIR));
	$c += !!md( $CFG{'SUITDIR'} . '/' . $SUIT );
	$c += !!md( $CFG{'SUITDIR'} . '/' . $SUIT . '/' . $CFG{$_} ) for (qw(SERVERS SCRIPTS RESULTS));
	say "$c directories created";
	exit 0;
}

pod2usage( -verbose => 0, -message => "$0: SUIT directory required $CFG{'SUITDIR'}\n" )
  unless -d $CFG{'SUITDIR'};

runit('RUN_BEGIN');

# Each argument can give us a combination test+servers, so we unite the list (to remove duplicates)
for my $argv (@ARGV) {
	my %SCRIPT_FILES;
	my @REG_SCRIPTS;
	my @REG_SERVERS;
	my ( $suit, $scripts, $hoststr );
	if ( index( $argv, '@' ) > -1 ) {
		( $scripts, $hoststr ) = split( '@', $argv, 2 );
		$scripts =~ s/(?:\b|^)$_\b/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
		$argv = $scripts . '@' . $hoststr;
	} else {
		$argv =~ s/(?:\b|^)$_\b/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
	}
	say "Processing ARG: $argv" if $CFG{'VERBOSE'};
	( $suit, $scripts ) =
	  index( $argv, ':' ) > -1 ? split( ':', $argv, 2 ) : ( $SUIT || $CFG{'SUIT'}, $argv );
	readCFG( $CFGFILE, $suit ) if ( $CFG{'_SELECTED_SUIT'} ne $suit );
	( $scripts, $hoststr ) = split( '@', $scripts, 2 ) if index( $argv, '@' ) > -1;
	$hoststr = '.' if $CFG{'UNFOLD'} && !$hoststr;
	$CFG{'ARGV'} = $argv;

	if ( index( $scripts, ' ' ) > -1 ) {
		push @ARGV, map { /:/ ? $_ : "$suit:$_" } split / +/, $scripts;
		next;
	}

	# make a proper scripts (add =* if not there)
	$scripts .= '=' unless index( $scripts, '=' ) > -1;
	$scripts =~ s/=$/=*/;
	$scripts =~ s/^=/*=/;

# allow for ALIASes to have %{} variables, and be expanded inside $scripts (but why did you use variables?).
	if ( index( $scripts, "%{" ) > -1 ) {
		updateTime( \%CFG );
		my $v = xexpand( $scripts, '%\{(\w+)\}', \%CFG );
	}

	# define the ./scripts/ and ./servers/ directories for this query (depends on the $suit)
	my $scriptsdir = $CFG{SUITDIR} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
	my $serversdir = $CFG{SUITDIR} . '/' . $suit . '/' . $CFG{'SERVERS'};
	say "scriptsdir=($scriptsdir) suit=($suit) scripts=($scripts) hoststr=($hoststr)"
	  if $CFG{'DEBUG'};
	$scriptsdir = abs_path($scriptsdir)
	  || pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $scriptsdir\n" );
	$serversdir = abs_path($serversdir)
	  || pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $serversdir\n" );

	# If we are using +, transform it to something glob can use to find servers
	my ( $reg_scripts, $reg_servers ) = split "=", $scripts, 2;
	readCFG($_)
	  if ( ( !$SUIT || index( $argv, ':' ) > -1 )
		&& -f ( $_ = "$CFG{SUITDIR}/$suit/$reg_scripts.cfg" ) );
	globlize($reg_servers);

	# Give me all scripts that match the scripts name, independant of servers
	@REG_SCRIPTS = map { basename($_) } glob( $scriptsdir . '/' . "$reg_scripts=*" );
	warn "Nothing found for SCRIPTS $scriptsdir/$scripts\n" unless @REG_SCRIPTS;

	# Now, for the found scripts, check the servers part and match it against it's $reg_server
	for my $script (@REG_SCRIPTS) {
		@REG_SERVERS = ();
		my ( $reg_script, $reg_server ) = split "=", $script, 2;
		next unless $reg_server;    # skip files that do not have servergroup candidates
		globlize($reg_server);
		say "For $script, search for servers: $reg_server in $serversdir argv:($argv)"
		  if $CFG{'DEBUG'};
		push( @REG_SERVERS, map { basename($_) } glob( $serversdir . '/' . $reg_server ) );
		warn "Nothing found for $CFG{'SERVERS'}/$reg_server\n" unless @REG_SERVERS;

		# And for that real server string representing a file, match our pattern $scripts
		for my $server (@REG_SERVERS) {
			my $scriptserver = $script;
			$scriptserver =~ s/=\K.*/$server/;
			my $scriptsreg = $scripts;
			globlize($scriptsreg);
			$scriptsreg .= '$';
			$scriptsreg =~ s/([\*\?])/.$1/g;    # glob-regexp to perl-regexp
			my $matches = $scriptserver =~ /$scriptsreg/;
			say
"check FIT argv: $argv script: $script scripts:$scripts\n scriptsreg: $scriptsreg scriptserver: $scriptserver\n"
			  . " server=$server  $scriptserver =~/ $scriptsreg / matches=$matches"
			  if $CFG{'DEBUG'};
			++$SCRIPT_FILES{ $suit . ':' . $script }{ $suit . ':' . $server } if $matches;

			if ($hoststr) {

				# TODO: give it a pointer to where $hoststr has regexp (split /,/)
				@{ $SCRIPT_FILES{ $suit . ':' . $script }{'!'} } = split /,/, $hoststr;
			}
		}
	}

# Now loop over all scripts and make sure they do not overlap tests. For example, say:
# You have test1=VM+ and test1=VM-ET, so the servergroup VM-ET matches both, clearly it is better to run test1=VM-ET
	if ( !$CFG{'NOAUTOFIX'} ) {
		my %TEST2SCRIPT;
		for my $suitscript ( sort keys %SCRIPT_FILES ) {
			my ( $test, $server ) = split "=", $suitscript, 2;
			push @{ $TEST2SCRIPT{$test} }, $suitscript;
		}
		for my $test ( sort keys %TEST2SCRIPT ) {
			my %SEEN;
			for my $suitscript ( sort { length($b) <=> length($a) || $a cmp $b }
				( @{ $TEST2SCRIPT{$test} } ) ) {
				for my $servergroup ( grep { !/^!$/ } keys %{ $SCRIPT_FILES{$suitscript} } ) {
					if ( $SEEN{ $test . '=' . $servergroup }++ ) {
						$SCRIPT_FILES{$suitscript}{$servergroup} = 0;
					}

				}
			}
		}
	}
	if ( $CFG{'DEBUG'} ) {
		no warnings;
		say "DEBUG: Variables list";
		updateTime( \%CFG );
		$CFG{N} += 1;    # simulate %{N} being set somewhat correctly.
		for my $key ( sort keys %CFG ) {
			say " \%{$key}=$CFG{$key}";
		}

		for my $key1 ( sort keys %SCRIPT_FILES ) {
			for my $key2 ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$key1} } ) {
				say "DEBUG: WOULD RUN $SCRIPT_FILES{$key1}{$key2} == $key1 => $key2";
			}
		}
	}

	for my $suitscript ( sort keys %SCRIPT_FILES ) {
		my ( $suit, $script ) = split ":", $suitscript, 2;
		my $scriptsdir = $CFG{SUITDIR} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
		$CFG{RUNSCRIPTSDIR} = $scriptsdir = abs_path $scriptsdir;
		my $resultsdir = $CFG{SUITDIR} . '/' . $suit . '/' . $CFG{'RESULTS'};
		$CFG{RUNRESULTSDIR} = $resultsdir = abs_path $resultsdir;
		for my $suitserver ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$suitscript} } ) {
			if ( $SCRIPT_FILES{$suitscript}{$suitserver} == 0 ) {
				say "SKIPPING $suitscript $suitserver ($SCRIPT_FILES{$suitscript}{$suitserver})"
				  if $CFG{'DEBUG'};
				next;
			}
			my ( $suit, $server ) = split ":", $suitserver, 2;
			my $serversdir = $CFG{SUITDIR} . '/' . $suit . '/' . $CFG{'SERVERS'};
			$CFG{RUNSERVERSDIR} = $serversdir     = abs_path $serversdir;
			$CFG{RUNSUIT}       = $suit;
			$CFG{RUNNAME}       = $CFG{RUNSCRIPT} = $script;
			$CFG{RUNNAME} =~ s/=.*//;
			$CFG{RUNSERVER}   = $server;
			$CFG{RUNSCRIPTFQ} = $CFG{RUNSCRIPTSDIR} . '/' . $CFG{RUNSCRIPT};
			$CFG{RUNSERVERFQ} = $CFG{RUNSERVERSDIR} . '/' . $CFG{RUNSERVER};

			if ( $CFG{UNFOLD} && !defined $RICH{ $CFG{RUNSERVERFQ} } ) {
				if ( !defined $RICH{ $CFG{RUNSERVERFQ} } ) {

			# read file if we havent done so, and check if it contains nested files, or sidecomments
					readfiletoarray( $CFG{RUNSERVERFQ} );

					if ( $CFG{'UNFOLDED'} || $CFG{'RICH'} ) {
						$RICH{ $CFG{RUNSERVERFQ} } = 1;
					} else {
						$RICH{ $CFG{RUNSERVERFQ} } = 0;
					}
				}
				push @{ $SCRIPT_FILES{$suitscript}{'!'} }, '.' if $RICH{ $CFG{RUNSERVERFQ} };
			}

			if ( defined $SCRIPT_FILES{$suitscript}{'!'} ) {
				say "###$script:opening $CFG{RUNSERVERFQ} for $CFG{RUNSCRIPTFQ}" if $CFG{'DEBUG'};
				my @read_servers = readfiletoarray( $CFG{RUNSERVERFQ} );
				my @servers;
				my $counter = 0;
				while ( $_ = shift @read_servers ) {
					chomp;
					my $found = 0;
					++$counter;
					for my $regexp ( @{ $SCRIPT_FILES{$suitscript}{'!'} } ) {
						say "looking if $_ matches $regexp" if $CFG{'DEBUG'};
						if ( $regexp =~ /^#(\-?\d+)/
							? ( $1 > 0 ? $counter == $1 : $#read_servers + 2 == -$1 )
							: m/$regexp/ix ) {
							s/\s+.*//;
							push @servers, $_;
							last;
						}
					}
				}

				close(FIN);

				say "Filter(\@) matched "
				  . ( $#servers + 1 )
				  . " out of $counter from $CFG{RUNSERVERFQ} UNFOLDED=$CFG{'UNFOLDED'} RICH=$CFG{'RICH'} UNFOLD=$CFG{'UNFOLD'} ~> $RICH{$CFG{RUNSERVERFQ}}"
				  if $CFG{'DEBUG'};
				next unless @servers;    # no matches, skip this test
					 # only create a temporal file if we do not match ALL servers in this group.
				if ( $#servers + 1 < $counter || $RICH{ $CFG{RUNSERVERFQ} } ) {
					my $tempfile =
						( $suit eq ".." ? '_' : $suit ) . '#'
					  . $script . '#'
					  . $server . '#'
					  . $CFG{PID};
					push @{ $CFG{_CLEANUP} }, ( $CFG{RUNSERVERFQ} = $CFG{TEMP} . '/' . $tempfile );
					$CFG{RUNSERVERSDIR} = $CFG{TEMP};
					$CFG{RUNSERVER}     = $server = $tempfile;
					open( FOUT, '>', $CFG{RUNSERVERFQ} ) or abort("$CFG{RUNSERVERFQ}: $!");
					say FOUT $_ for @servers;
					close FOUT;
				}
			}

			# enquote
			if ( $CFG{QUOTE} ) {
				for my $fq (qw(RUNSCRIPTFQ RUNSERVERFQ)) {
					$CFG{$fq} =~ s/($CFG{QUOTESTR})/\\$1/g;
					$CFG{$fq} = $CFG{QUOTESTR} . $CFG{$fq} . $CFG{QUOTESTR};
				}
			}

			if ( $CFG{FOLD} || $CFG{GROUP} || $CFG{BUNDLE} ) {
				$DEFER{ $CFG{RUNSCRIPTFQ} }{ $CFG{RUNSERVERFQ} }++;
			} else {
				$CFG{RUNNAMES} = $CFG{RUNNAME};
				&executerun();
			}
		}
	}
}

if (%DEFER) {

	if ( $CFG{'GROUP'} ) {
		for my $script ( keys %DEFER ) {
			my $str = join $CFG{SEPARATOR}, sort keys %{ $DEFER{$script} };
			undef $DEFER{$script};
			$DEFER{$script}{"$str"} = 1;
		}
	}

	if ( $CFG{'FOLD'} ) {
		my %FOLD;
		for my $k ( keys %DEFER ) {
			for my $v ( keys %{ $DEFER{$k} } ) {
				$FOLD{$v}{$k} = 1;
			}
		}
		%DEFER = ();
		for my $k ( keys %FOLD ) {
			my $str = join $CFG{SEPARATOR}, sort keys %{ $FOLD{$k} };
			$DEFER{$str}{$k} = 1;
		}
	}

	$CFG{RUNNAMES} = join '+', grep { s{.*/}{}; s{=.*}{}; } sort keys %DEFER;

	for my $scripts ( sort keys %DEFER ) {
		$CFG{RUNSCRIPTFQ} = $scripts;
		for my $servers ( sort keys %{ $DEFER{$scripts} } ) {
			$CFG{RUNSERVERFQ} = $servers;

			if ( $CFG{BUNDLE} ) {
				if ( index( $scripts, $CFG{SEPARATOR} ) > -1 ) {
					my $tempfile =
						( $CFG{RUNSUIT} eq ".." ? '_' : $CFG{RUNSUIT} )
					  . '#BUNDLESCRIPTS#'
					  . $CFG{N} . '#'
					  . $CFG{PID};
					push @{ $CFG{_CLEANUP} }, ( $CFG{RUNSCRIPTFQ} = $CFG{TEMP} . '/' . $tempfile );
					say "# BUNDLING SCRIPTS $scripts" if $CFG{VERBOSE};
					$CFG{RUNSCRIPTSDIR} = $CFG{TEMP};
					$CFG{RUNSCRIPT}     = $tempfile;
					open( FOUT, '>', $CFG{RUNSCRIPTFQ} ) or abort("$CFG{RUNSCRIPTFQ}: $!");
					for my $file ( split /$CFG{SEPARATOR}/, $scripts ) {
						say "## BUNDLING SCRIPT $file" if $CFG{DEBUG};
						say FOUT $_ for readfiletoarray($file);
					}
					close FOUT;
				}

				if ( index( $servers, $CFG{SEPARATOR} ) > -1 ) {
					my $tempfile =
						( $CFG{RUNSUIT} eq ".." ? '_' : $CFG{RUNSUIT} )
					  . '#BUNDLESERVERS#'
					  . $CFG{N} . '#'
					  . $CFG{PID};
					push @{ $CFG{_CLEANUP} }, ( $CFG{RUNSERVERFQ} = $CFG{TEMP} . '/' . $tempfile );
					say "# BUNDLING SERVERS $servers" if $CFG{VERBOSE};
					$CFG{RUNSERVERSDIR} = $CFG{TEMP};
					$CFG{RUNSERVER}     = $tempfile;
					open( FOUT, '>', $CFG{RUNSERVERFQ} ) or abort("$CFG{RUNSERVERFQ}: $!");
					for my $file ( split /$CFG{SEPARATOR}/, $servers ) {
						say "## BUNDLING SERVER $file" if $CFG{DEBUG};
						say FOUT $_ for readfiletoarray($file);
					}
					close FOUT;
				}
			}

			my $script = $CFG{RUNSCRIPTFQ};
			my $server = $CFG{RUNSERVERFQ};
			$script =~ s{$CFG{RUNSCRIPTSDIR}/}{}g;
			$server =~ s{$CFG{RUNSERVERSDIR}/}{}g;
			$CFG{RUNSCRIPT} = $script;
			$CFG{RUNSERVER} = $server;
			&executerun();
		}
	}
}

if ( !$CFG{'KEEP'} ) {
	for my $tmpfile ( @{ $CFG{_CLEANUP} } ) {
		say "removing temporal file $tmpfile" if $CFG{'VERBOSE'};
		unlink $tmpfile;
	}
}

runit('RUN_FINISH') if $BASECFG{RUN_STARTED};
runit('RUN_END');
exit 0;

sub executerun
{
	if ( $CFG{ARG} ) {
		if ( ref $CFG{ARG} eq "ARRAY" ) {
			$CFG{ARG} = join " ", @{ $CFG{ARG} };
		}
	}
	if ( $CFG{'VERBOSE'} ) {
		say "# RUN($CFG{'ARGV'}) $CFG{RUNSUIT}:$CFG{RUNSCRIPT} on $CFG{RUNSERVER}"
		  . ( $CFG{ARG} ? " with argument '$CFG{ARG}'" : "" );
		say "# SCRIPT=$CFG{RUNSCRIPTFQ}";
		say "# SERVER=$CFG{RUNSERVERFQ}";
	}
	$CFG{N} = $BASECFG{N} += 1;    # Unique counter %{N} (combine with %{PID} to create tempfiles)
	my $EC;
	my $REDO = defined $CFG{'REDO'} ? $CFG{'REDO'} : 0;
	for my $run ( glob "{RUN}{_PRE,,_POST}{_TEST,}" ) {
		next if $run =~ /_TEST$/ && !defined $CFG{'TEST'};
	  REDO:
		if ( $CFG{'ARG'} && defined $CFG{ $run . "_ARG" } ) {
			$EC = runit( $run . "_ARG", $run ne "RUN_PRE" );    # update time only for RUN_PRE
		} else {
			$EC = runit( $run, $run ne "RUN_PRE" );             # update time only for RUN_PRE
		}
		if ( $EC && $REDO > 0 && $run eq "RUN" ) {
			--$REDO;
			goto REDO;
		}
		last if ( $EC && $run =~ /_TEST|RUN_PRE/ );
	}
}

# allow executing ABORTMSG before die (usually from lacking permissions to read/write files)
sub abort
{
	$CFG{'ABORTMSG'} = $_[0];
	runit('RUN_ABORT');
	die $_[0] . "\n";
}

# Run (or dryrun) the commands defined as RUN... in the cfg file
sub runit
{
	my ( $KEY, $no_time_update ) = @_;
	if ( $_ = $CFG{$KEY} ) {
		updateTime( \%CFG ) unless $no_time_update;
		xexpand( $_, '%\{(\w+)\}', \%{ $CFG{'ALIAS'} } ) if index( $_, "%{" ) > -1;
		xexpand( $_, '%\{(\w+)\}', \%CFG ) if index( $_, "%{" ) > -1;
		if ( $CFG{DRYRUN} ) {
			say "# RUN_START:\n" . $CFG{RUN_START}
			  if ( defined $CFG{RUN_START} && !$BASECFG{RUN_STARTED}++ );
			say "# $KEY:\n" . $_;
		} else {
			if ( defined $CFG{RUN_START} && !$BASECFG{RUN_STARTED}++ ) {
				say $CFG{RUN_START} if $CFG{'VERBOSE'};
				system $CFG{RUN_START};
			}
			say $_ if $CFG{'VERBOSE'};
			my $ec = system $_;
			say " # ExitCode=$?" if $CFG{'VERBOSE'};
			$CFG{'ERRORCODE'} = $ec >> 8;
			runit( $KEY . "_FAIL", 1 ) if ( $ec && $KEY !~ /_FAIL$/ && $CFG{ $KEY . "_FAIL" } );
			return $ec;
		}
	}
	return 0;
}

# transform lazy search into a glob-able pattern
sub globlize
{
	$_[0] =~ s/^(\+\+)|(=\K\+\+)|(\+\+)$/$1||$2?"*-":"-*"/ge;
	while ( $_[0] =~ s/\+\+|\-\-/-*-/g ) { }
	$_[0] =~ s/\+/\*/g;
	$_[0] =~ s/^(\-)|(\-)$/$2\*$1/g;
}

# xexpands %{} variables
sub xexpand
{
	$_[0] =~ s/$_[1]/$_[2]{$1}?$_[2]{$1}:"%{$1}"/ge;
	$_[0];
}

# Time variables used in AUTOMAINTENANCE expressions
sub updateTime
{
	my ( $v, $e ) = @_;
	$v->{"EPOCH"} = $e = ( $e || time );
	my @T = $CFG{UTC} ? gmtime($e) : localtime($e);    # S M H d m+1 y+1900 wd yd daylightsaving
	$v->{"HH"} = $T[2] < 10 ? '0' . $T[2] : $T[2];     # hour (00..23)
	$v->{"MM"} = $T[1] < 10 ? '0' . $T[1] : $T[1];     # minute (00..59)
	$v->{"SS"} = $T[0] < 10 ? '0' . $T[0] : $T[0];     # seconds (00..23)
	$v->{"WD"} = $T[6] || 7;                           # 1=Monday ... 6=Saturday, 7=Sunday
	$v->{"YD"} = sprintf( "%03d", $T[7] + 1 )
	  ;    # day of the year, in the range 001..365 (or 001..366 if leap year)
	$v->{"DAY"}   = $T[3] < 10   ? '0' . $T[3] : $T[3];    # day of the month
	$v->{"MONTH"} = ++$T[4] < 10 ? '0' . $T[4] : $T[4];    # 01=jan ... 12=dec
	$v->{"YEAR"} = $T[5] + 1900;                           # 4 digits year
	$v->{"DS"}   = $T[8];                                  # daylightsaving

	$v->{"TOTALTIME"} = time - $^T;                        # total seconds running
}

sub readfiletoarray
{
	my ( $_file, $_recursed ) = @_;
	say "readfiletoarray($_file,$_recursed)" if $CFG{'DEBUG'};
	$CFG{'UNFOLDED'} = $CFG{'RICH'} = 0 unless $_recursed;
	open( FIN, '<', $_file ) or abort("$_file: $!");
	my @_SVRS;
	while (<FIN>) {
		chomp;
		if (/\//) {
			$CFG{'UNFOLDED'}++;    # signal that we unfolded
			push @_SVRS, readfiletoarray( $_, 1 );
		} else {
			$CFG{'RICH'}++ if /\s/;    # signal we have a commented hostfile
			push @_SVRS, $_;
		}
	}
	close(FIN);
	@_SVRS;
}
__END__

=head1 NAME

evidencer.pl - A program to join servers and scripts

=head1 SYNOPSIS

 evidencer [-s <suit>] [suit:][script]=[servergroup][@<hostnames_regexp,...>] [--help]

=head1 DESCRIPTION

./servers/  Define a list of server by function.

./scripts/  Define a list of tests, by function, to be run on those servers

./results/  Just an empty directory to store results in (from an external program)

./suits/    Once you are done with your tests, move them away into a suit, still available

./tmp/      A temporal directory to hold sub lists of servergroups when using hostnames_regexp

To create a suits directory structure:
./evidencer -C -s MYAPPL

=head1 OPTIONS

 [OPT         DESCRIPTION]

 --help       Print Options and Arguments.
 --man        Print complete man page.
 --verbose    Log more to the screen
 --DEBUG      Log a bit more to the screen
 --dryrun     Do not execute, but show all that would have been run
 --UTC        timestrings are in UTC instead of localtime
 --CREATEDIRS Create directories if they do not exist
 --config $configuration_file   Read alternative cfg file
 --keep       Do not cleanup temporal files created to accomodate the @hostnames list
 --noautofix  Do not skip running tests on servergroups that match multiple tests
 --unfold     If you have files in your servergroups, recursively read the servers.
 --fold       Group by Scripts
 --group      Group by Servergroups
 --bundle     Concatenate all scripts/servers if they are folded or grouped, into a new file
 --redefine $ Override a variable from evidencer.cfg (can be used multiple times)
 --argument $ Quick redefine that sets %{ARG} for use in RUN*_ARG scripts (if defined).
 --quote      Quote your scripts and servers using %{QUOTESTR}. Handy for fold and group.
 --SEPARATOR $ The separation characters between folded and grouped items. (default is double space)
 --test $     Final test against a RUN (either before or after RUN_PRE) to validate the combination
 --suit <suit>  Only consider this suit for all script-server matches

Options can be anywhere in the commandline (but not after the `--` parameter). Options can be shortened (1st letter) and can be bundled.

 Example:
 
 # Run, from the suit JAVATRANSACTIONS the test JAVASERVER-SERVICES= for servers JAVA-ET
 # that match the perl regexp javaserver00[1..5] or the substring javaserver0100
 ./evidencer JAVATRANSACTIONS:JAVASERVER-SERVICES=JAVA-ET@javaserver00[1..5],javaserver0100
 
 # show (dryrun) what would run from the suit JAVATRANSACTIONS the test 
 # JAVASERVER-SERVICES= for any matching servers AND the test JAVASERVER-PORTS for any of it's
 # matching servers
 ./evidencer -s JAVATRANSACTIONS JAVASERVER-SERVICES=* JAVASERVER-PORTS -d

 JAVASERVER-SERVICES=* can be written as:
   JAVASERVER-SERVICES=  or as  JAVASERVER-SERVICES=+  or even as  JAVASERVER-SERVICES
 
 The servergroup, can use a plus sign instead of an asterix, and these are the rules:
 +     ==>  *       ++    ==>  *-*     +-+-+ ==>  *-*-*
 +A    ==>  *A      A+    ==>  A*      ++B   ==>  *-B
 +-A   ==>  *-A     A-+   ==>  A-*     A++   ==>  A-*
 A++B  ==>  A-*-B   A-+B  ==>  A-*B    A+-B  ==>  A*-B

 So if you have a servergroup called APACHE-PROD-DMZ, then =++DMZ would match that group.
 And ++PROD++  would match *-PROD-*. These are glob expansions, which means it would match
 exactly what ls would match if you run:  ls ./servers/*-PROD-*
 
 If unsure, escape or quote your servergroup and use dryrun.
 
 @hostnames regexp's are not un-ALIAS-ed.
 
=head1 LICENSE

This software is released under the Unlicense statement.
It is free and unencumbered software released into the public domain.
If you don't know what that means visit L<https://unlicense.org/>.

=cut
