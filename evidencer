#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
Getopt::Long::Configure("bundling");
BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
use Pod::Usage;
use File::Basename qw(dirname basename fileparse fileparse_set_fstype);
use Cwd qw(abs_path getcwd);
use feature 'say';

my $CFGFILE;
my %DEFER;    # for GROUP or (UN)FOLD
my @DEFERARR; # Keep the execution order as much as possible
my %CFGSTOR;
my %RICH;     # for forcing a new servergroup file
my %CFG;      # Variable configuration
my %_CFG;     # BASE configuration
my $MELINKED = -l $0;    # holds if the current file is a symlink (changes behavior)
my %BASECFG  = (
	PID       => $$,
	N         => 0,
	UTC       => 0,
	NEWLINE   => "\n",
	SEPARATOR => "  ",
	ARG       => undef,
	QUOTESTR  => "'",
	CFGDIR    => "cfg",
	TOTALERRORS => 0,
	# COLORS
	'C:'  => "\033[0m", # Normal
	'C:N' => "\033[0m", # Normal
	'C:B' => "\033[1m", # BOLD
	'C:I' => "\033[3m", # ITALIC
	'C:U' => "\033[4;37m", # UNDERLINE
	'C:R' => "\033[1;31m", # RED
	'C:G' => "\033[1;32m", # GREEN
	'C:Y' => "\033[1;33m", # YELLOW
	'C:L' => "\033[1;34m", # BLUE
	'C:P' => "\033[1;35m", # PURPLE (officially Fuchsia/Magenta)
	'C:C' => "\033[1;36m", # CYAN
	'C:Z' => "\033[7;1m", # INVERT
	'C:A' => "\033[0;90m", # GRAY
	'C:O' => "\033[38;5;208m", # ORANGE (might not be available on all terminals)
	NOCOLORS => 0, # set to 1 in the evidencer.cfg file to disable colored help
);

my $SUIT = $ENV{'SUIT'} || "";
$SUIT = $1 if ( !$SUIT && getcwd() =~ m{/suits/(\w+)} );

my %opt;
my ( $opt_help, $opt_man, $opt_complete );

# Store original ARGV, we use it with Completions, where the COMP_CWORD shift when using modifier arguments
my @_ARGV = @ARGV;

# Before GetOptions, check if we have a -- and grab the arguments into %{ARG}
if ( grep /^\-\-$/, @ARGV ) {
	@_ = ();
	while ( ( $_ = pop @ARGV ) ne '--' ) {
		unshift @_, $_;
	}
	$BASECFG{ARG} = join " ", @_;
}

our %OPTIONS = (
	'h|help|?!'     => \$opt_help,
	'man!'          => \$opt_man,
	'complete!'     => \$opt_complete,
	'c|config=s'    => \$CFGFILE,
	'D|DEBUG'       => \$BASECFG{DEBUG},
	'v|verbose'     => \$BASECFG{VERBOSE},
	'd|dryrun'      => \$BASECFG{DRYRUN},
	'U|UTC'         => \$BASECFG{UTC},
	'C|CREATEDIRS'  => \$BASECFG{CREATEDIRS},
	'k|keep'        => \$BASECFG{KEEP},
	'n|noautofix'   => \$BASECFG{NOAUTOFIX},
	'u|unfold'      => \$BASECFG{UNFOLD},
	'f|fold'        => \$BASECFG{FOLD},
	'g|group'       => \$BASECFG{GROUP},
	'b|bundle'      => \$BASECFG{BUNDLE},
	'r|redefine=s@' => \$BASECFG{REDEFINE},
	's|suit:s'      => \$SUIT,
	'S|SEPARATOR:s' => \$BASECFG{SEPARATOR},
	'a|argument:s'  => \$BASECFG{ARG},
	'q|quote'       => \$BASECFG{QUOTE},
	't|test:s'      => \$BASECFG{TEST},
	'w|warnings'    => \$BASECFG{WARNINGS},
	'query=s@'      => \$BASECFG{QUERY},
	'l|loop=s@'     => \$BASECFG{LOOP},
	'o|on=s@'       => \$BASECFG{ON},
);

GetOptions(%OPTIONS) or pod2usage( -verbose => 0 );

# Do not override these from configuration file if set from the commandline through params
my %DONOTOVERRIDE = map { $_ => 1 } qw(DEBUG VERBOSE DRYRUN CREATEDIRS FORCE);

pod2usage( -verbose => 1 ) if defined $opt_help && !@ARGV;
pod2usage( -verbose => 2 ) if defined $opt_man;

# Make sure at least one argument provided
if ( !$opt_complete && !@ARGV && !$BASECFG{'CREATEDIRS'} && !$BASECFG{'QUERY'} ) {
	pod2usage( -verbose => 0, -message => "$0: one argument required" );
}

# Read configuration file
sub readCFG
{
	my ( $NEWCFG, $NEWSUIT ) = @_;
	$NEWCFG  = $NEWCFG  || '';
	$NEWSUIT = $NEWSUIT || '';
	my $me = dirname( abs_path( $MELINKED ? dirname($0).'/'.readlink($0) : $0 ) ) . '/' . basename($0);
	my $BASEDIR = dirname $me;
	%CFG = (
		$NEWCFG && !$NEWSUIT ? %CFG : %BASECFG,
		(
			'BASEDIR'        => $BASEDIR,
			'TEMP'           => $BASEDIR . "/tmp",
			'SUITSDIR'       => $BASEDIR . "/suits",
			'SUIT'           => $NEWSUIT || $CFG{'SUIT'} || '..',
			'SERVERS'        => 'servers',
			'SCRIPTS'        => 'scripts',
			'RESULTS'        => 'results',
			'_SELECTED_SUIT' => $NEWSUIT || $CFG{'SUIT'} || '..',
			'ERRORCODE'      => 0,
			'RUN_BEGAN'      => 0,
			'CFGDIR'         => $BASECFG{'CFGDIR'},
		)
	);

	updateTime( \%CFG );    # cfgfile might need the variables.
	my ( $name, $path, $suffix ) = fileparse( $me, '.pl' );
	my $_CFGFILE = $NEWCFG
		|| (
			$NEWSUIT
			? $CFG{'SUITSDIR'} . '/' . $NEWSUIT . '/' . $name . '.cfg'
			: $path . $name . '.cfg' );
	-f $_CFGFILE
		|| -f ( $_CFGFILE = $CFG{'SUITSDIR'} .'/'. $NEWSUIT .'/'. $CFG{'CFGDIR'} .'/'. $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . $CFG{'CFGDIR'} .'/'. $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . '../' . $CFG{'CFGDIR'} .'/'. $name . '.cfg' );

	if ( -f $_CFGFILE ) {
		$CFG{'CFGFILE'} = $_CFGFILE;
		say "readCFG($NEWCFG,$NEWSUIT)=$_CFGFILE" if $BASECFG{'VERBOSE'} && !$opt_help && !$opt_complete;
		open( my $CFG, '<', $_CFGFILE ) or abort("$_CFGFILE $!");
		my %DIRS = map { $_ => 1 } qw(TEMP);
		while (<$CFG>) {
			next if /^#/ || !/=/;
			chomp;
			s/\s+$//;
			$_.=$_[0] while($_=~s/\\$// && chomp($_[0]=<$CFG>));
			if (/^ALIAS\s+([^=]+)\s*=\s*(.*)\s*/) {
				$CFG{'ALIAS'}{$1} = $2;
			} else {
				my ( $k, $v ) = split /=/, $_, 2;
				$v = xexpand( $v, '%\{(\w+)\}', \%CFG ) if index( $v, "%{" ) > -1;
				$v = abs_path($v) if $DIRS{$k};
				$CFG{$k} = $v unless $DONOTOVERRIDE{$k} && defined $CFG{$k};
			}
		}
	}
	for my $k (qw(SUIT)) {
		$CFG{$k} = $ENV{$k} if defined $ENV{$k};
	}
	if ( $CFG{'REDEFINE'} ) {
		&redefine();
	}
}

readCFG( $CFGFILE ); # Read toplevel evidencer.cfg only for CFGDIR
$BASECFG{'CFGDIR'} = $CFG{'CFGDIR'} if $CFG{'CFGDIR'} ne $BASECFG{'CFGDIR'};
readCFG( $CFGFILE, $SUIT ) if $SUIT;

# Get a single variable defined in the .cfg file, and print it out.
if(defined $BASECFG{'QUERY'}){
	say $_.'='.($CFG{$_}?$CFG{$_}:"") for (@{$BASECFG{'QUERY'}});
	exit;
}

%_CFG = UnDeepCopy( \%CFG );    # Backup real base configuration so each test can change it
say "BASEDIR=$CFG{'BASEDIR'} CFGFILE=$CFG{'CFGFILE'}" if $CFG{'DEBUG'};

# Help for the last argument given.
# Add verbose: -hv  to also show the extra help #+: in the script
# Add a + in the argument to search for the term in-between the method scripts
# use a dot to show all help from all scripts that have it
if($opt_help && @ARGV && !$opt_complete) {
	my $SUITDIR = $CFG{'SUITSDIR'}.'/'.$CFG{'SUIT'}.'/';
	# Read all fils in ./scripts/ that are methods (i.e. have the form: script=serverfilter)
	my @methods = grep { /=/ && -x "${SUITDIR}$CFG{'SCRIPTS'}/$_" } getdir(${SUITDIR}.$CFG{'SCRIPTS'});

	my %K;
	my $search = pop @ARGV; # only consider the last argument parameter given
	$search =~ s/=\K.*//; # remove the server part, if there

	# Deep search for a word inside anny comments in the scripts, and display that method
	my $better = $search=~s/\+//;
	if($better){
		for my $k (@methods){
			++$K{$k} if readfiletoarray("${SUITDIR}$CFG{'SCRIPTS'}/$k",-1,"#.*$search");
		}
		@methods = keys %K; # show help for all methods found with the searchterm
	}else{
		%K=();
		++$K{$_} for grep { /$search/i } @methods; # search in names only
	}

	{ no warnings;
	for my $k (sort keys %K){
		my ($title) = split /=/, $k;
		my @txt = readfiletoarray("${SUITDIR}$CFG{'SCRIPTS'}/$k",-1, $BASECFG{'VERBOSE'}? "^#.\?:": "^#:");
		next unless @txt;
		grep s/<(?:.|\d+):?>//g, @txt if $CFG{'NOCOLORS'};
		grep s/<([BRUINGLYPCAZO])>(\S+)/$BASECFG{'C:'.$1}$2$BASECFG{'C:N'}/g, @txt; # <B>word
		grep s/<(\w*):>/ $1 ? ( $1>0 ? "\033[38;5;${1}m" : "$BASECFG{'C:'.$1}" ) : $BASECFG{'C:N'}/ge, @txt; #<123:> ... <:>
		grep s/<(\d+)>(\S+)/\033[38;5;${1}m$2$BASECFG{'C:N'}/g, @txt; # <123>word
		say "\n=== " . ($CFG{'NOCOLORS'}>1? '':$BASECFG{'C:B'}) . "${title}" . ($CFG{'NOCOLORS'}>1? '':$BASECFG{'C:N'}) . " ===\n";
		say join "\n", grep { s/^#\+?:// } @txt;
		say "";
	}
	}

	exit 0;
}

# Completions
#
## # if [[ "${-}" =~ 'i' ]];then  #Uncomment to not load when running non-interactively
## function _getopt_complete () {
##  COMPREPLY=($( COMP_CWORD=$COMP_CWORD perl `which ${COMP_WORDS[0]}` --complete ${COMP_WORDS[@]:0} ));
## };
## complete -F _getopt_complete evidencer
## # fi
#
if ($opt_complete)
{
	# print completion code
	unless($ENV{'COMP_CWORD'}){
		say join "\n", grep { s/## // && (!/-F/ || (@ARGV?s/\w+$/$ARGV[0]/:s/\w+$/basename($0)/e)) && !/# / } readfiletoarray($0, -1, '^##');
		exit
	};
	my $SUITDIR = $CFG{'SUITSDIR'}.'/'.$CFG{'SUIT'}.'/';

	my $search = "";
	my @candidates;
	my %K;
	my $m = $#_ARGV - $ENV{'COMP_CWORD'};

	$search = $_ARGV[ $ENV{'COMP_CWORD'} +1 ] || "";

	# special case: SUIT
	if($_ARGV[-1] eq '-s' && ($m>0)){
		say "-s"; exit;
	}
	if(($_ARGV[-1] eq '-s')||($_ARGV[-2] eq '-s' && (! -d $CFG{'SUITSDIR'}.'/'.$_ARGV[-1] || ($m>0)))){
		my @suits = grep { -d "$CFG{'SUITSDIR'}/$_" } getdir($CFG{'SUITSDIR'} );
		$search=$_ARGV[-1] eq '-s' ? '.' : $_ARGV[-1];
		@candidates = grep {/^$search/} @suits;
		say join " ", @candidates;
		exit;
	}

	# $search =~s/\\=/=/; # remove backquote before equals, set by Completions
	my $realsearch = $search;

	# Process parameters that start with -
	if ( $_ARGV[-1] =~ m/^\-/ && $m >0) {
		$search = $_ARGV[-1];
		my $dashes = 0;
		@candidates = keys %OPTIONS;
		if ( $search =~ s/^\-\-// ) {
			s/^.\||[:=].*$// for @candidates;
			$dashes = 2;
		} elsif ( $search =~ s/^\-// ) {
			s/\|.*// for @candidates;
			$dashes = 1;
			push @candidates, '-';
		}
		s/:.*// for @candidates;
		if($search){
			@candidates = map { $_ = '-' x $dashes . $_ } grep {/^$search/} @candidates;
		}else{
			@candidates = map { $_ = '-' x $dashes . $_ } @candidates;
		}
		say join " ", sort @candidates;
		exit 0;
	}

	# Process ALIAS that start with /
	if ( $_ARGV[-1] =~ m/^\// && $m >0) {
		$search = $_ARGV[-1];
		say join " ", grep { /^$search/ }  (sort keys %{$CFG{'ALIAS'}});
		exit 0;
	}

	my @methods = grep { /=/ && -x "${SUITDIR}$CFG{'SCRIPTS'}/$_" } getdir(${SUITDIR}.$CFG{'SCRIPTS'});

	my @serverfiles = grep { /=/ && -x "${SUITDIR}$CFG{'SERVERS'}/$_" } getdir(${SUITDIR}.$CFG{'SERVERS'});

	$search =~ s/[.]/\\./; # escape dot
	if ( !$search ) {
		# If we have nothing yet, suggest methods up until the first point (if they have)
		my @M = @methods;
		++$K{$_} for grep { s/=\K.*//; s/\..*/\./ || s/=\K.*// } @M;
		@candidates = keys %K;
		unless ($#candidates == 0 && $candidates[0] =~ /[\.=]$/){
			say join " ", @candidates;
			exit ;
		}
	} elsif ( $search !~ /=/ && $_ARGV[ $ENV{'COMP_CWORD'} ] ne '=' ) {
		my @M = @methods;
		if($search=~s/\+/.*/g){
			++$K{$_} for grep { /$search/ } @M;
		}else{
			++$K{$_} for grep { s/^$search[^\.]*?\K\..*/\./ || /^$search/ } grep { /^$search/ } @M;
		}
		@candidates = keys %K;
	}
	if ((@ARGV && $_ARGV[ $ENV{'COMP_CWORD'} ] eq '=') || $search eq '=' ) {
		$search =
			$search eq '='
			? $_ARGV[ $ENV{'COMP_CWORD'} ] . '=+'
			: $_ARGV[ $ENV{'COMP_CWORD'} - 1 ] . '=' . $search;
		@candidates = ( $search );
	}

	if ( $#candidates == 0 && $candidates[0] !~ /=/ ) {
		$search = $candidates[0];
		@candidates = grep { /^$search[^\.]*/ } @methods;
	}

	%K = ();
	my %T = ();

	for my $k (@candidates) {
		%CFG = UnDeepCopy( \%_CFG );
		if ( $k !~ /=/ ) {
			++$K{$k};
		} else {
			my %X = getscripts( getSuitAndScriptsAndHostStr($k), $k );
			for my $i ( keys %X ) {
				for my $j ( keys %{ $X{$i} } ) {
					my $a = $i;
					my $b = $j;
					$a =~ s/=.*//;
					$b =~ s/.*://;
					$a =~ s/.*:// unless $k =~ /:/;
					++$K{$a};
					my $c = "$a=$b";
					$c =~ s/.*=//
					  if ( $realsearch !~ /=/ && $_ARGV[ $ENV{'COMP_CWORD'} ] eq '=' )
					  || $realsearch eq '=';
					++$T{$c};
				}
			}
		}
	}

	# if we have more than 1 test, only display testnames, else also with servernames
	if ( scalar keys %K > 1 ) {
		say join " ", sort keys %K;
	} else {
 		say join " ", sort keys %T;
	}

	exit;
}

sub md
{
	if ( !-d $_[0] ) {
		say "mkdir $_[0]";
		mkdir $_[0];
		return 1;
	} elsif ( $CFG{'VERBOSE'} || $CFG{'DEBUG'} ) {
		say "#Directory already exists: $_[0]";
		return 0;
	}
}

if ( $CFG{'CREATEDIRS'} ) {
	$SUIT = $SUIT || $CFG{'SUIT'};
	my $c = 0;
	$c += !!md( $CFG{$_} )                                       for (qw(TEMP SUITSDIR));
	$c += !!md( $CFG{'SUITSDIR'} . '/' . $SUIT );
	$c += !!md( $CFG{'SUITSDIR'} . '/' . $SUIT . '/' . $CFG{$_} ) for (qw(SERVERS SCRIPTS RESULTS));
	say "$c directories created";
	exit 0;
}

pod2usage( -verbose => 0, -message => "$0: SUIT directory required $CFG{'SUITSDIR'}\n" )
  unless -d $CFG{'SUITSDIR'};

if ( defined $BASECFG{'ON'} ) {
    my $tempserverfile = $CFG{'TMPFILE'}? $CFG{'TMPFILE'} : 'tmp.lst';
    my $tempserverfilefq = $CFG{'SUITSDIR'} .'/'. $SUIT .'/'. $CFG{'SERVERS'} .'/'. $tempserverfile;
    say "Saving ON list to $tempserverfilefq" if $CFG{'DEBUG'};
    open(my $sfh, '>', $tempserverfilefq) or die "FATAL: $tempserverfilefq $!";
    for my $on (@{$BASECFG{'ON'}}){
        for my $svr (split /,/, $on){
            chomp $svr;
            say $sfh, $svr;
        }
    }
    close $sfh;
    push @{$BASECFG{'LOOP'}}, $tempserverfile;
}

runit('RUN_START');

# Split argument string into suit, scripts and hoststr (suit:scripts=+:hoststr)
sub getSuitAndScriptsAndHostStr
{
	my ($argv) = @_;
	$argv =~ s/\\=/=/;    # remove backquote before equals, when set by Completions
	$argv =~ s/\\:/:/;    # remove backquote before colon, when set by Completions
	$argv = unalias($argv);
	$CFG{'ARGV'} = $argv;
	my ( $suit, $scripts, $hoststr ) =
		index( $argv, ':' ) > -1 ? split( ':', $argv, 2 ) : ( $SUIT || $CFG{'SUIT'}, $argv );
	( $scripts, $hoststr ) = split( '@', $scripts, 2 ) if index( $argv, '@' ) > -1;
	if ( $CFG{'_SELECTED_SUIT'} ne $suit ) {
		%CFG = &UnDeepCopy( \%BASECFG );
		readCFG( $CFGFILE, $suit );
		$scripts = unalias($scripts);
	}

	# make a proper scripts (add =* if not there)
	$scripts .= '=' unless index( $scripts, '=' ) > -1;
	$scripts =~ s/=$/=*/;
	$scripts =~ s/^=/*=/;

	# allow for ALIASes to have %{} variables, and be expanded inside $scripts
	if ( index( $scripts, "%{" ) > -1 ) {
		updateTime( \%CFG );
		my $v = xexpand( $scripts, '%\{(\w+)\}', \%CFG );
	}
	return ( $suit, $scripts, $hoststr );
}

sub getscripts
{
	my ( $suit, $scripts, $hoststr, $argv ) = @_;
	my @REG_SCRIPTS;
	my @REG_SERVERS;
	my %SCRIPT_FILES;

	# define the ./scripts/ and ./servers/ directories for this query (depends on the $suit)
	my $scriptsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
	my $serversdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SERVERS'};
	say "scriptsdir=($scriptsdir) suit=($suit) scripts=($scripts) hoststr=($hoststr)"
		if $CFG{'DEBUG'};
	$scriptsdir = abs_path($scriptsdir)
		|| pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $scriptsdir\n" );
	$serversdir = abs_path($serversdir)
		|| pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $serversdir\n" );

	# Isolate the $reg_scripts, there might be a configuration file for it
	my ( $reg_scripts, $reg_servers ) = split /=/, $scripts, 2;

	# Read the config for the test, if it exists (merges configuration with existing).
	# Bug: when multiple inlines are run, then it does not clean up the cfg from prev.
	readCFG($_)
		if ( ( !$CFGFILE )
		&& ( -f ( $_ = "$CFG{SUITSDIR}/$suit/$reg_scripts.cfg" ) 
			|| -f ( $_ = "$CFG{SUITSDIR}/$suit/$CFG{CFGDIR}/$reg_scripts.cfg" )) );
	$CFG{'RUNSCRIPT'} = $reg_scripts; # make it available

	# If we are using +, transform it to something glob can use to find servers
	#globlize($reg_servers);

	# Give me all scripts that match the scripts name, independant of servers
	@REG_SCRIPTS = map { basename($_) } glob( $scriptsdir . '/' . "$reg_scripts=*" );
	warn "Nothing found for SCRIPTS $scriptsdir/$scripts\n"
		unless @REG_SCRIPTS || !$CFG{'WARNINGS'};

	# support for last modified scripts file. test=#
	my $last_only = 0;
	if($reg_servers eq '#'){
		$last_only=1;
	}else{
		$reg_scripts =~s/([*\[\]])/\\$1/g; # Escape asterix for glob to work
		# allow for script=file1,file2 by translating to: ^script=file1$|^script=file2$
		if($opt_complete){
			$scripts = join '|', glob "{\^}{$reg_scripts}={$reg_servers}";
		}else{
			$scripts = join '|', glob "{\^}{$reg_scripts}={$reg_servers}{\$}";
		}
	}

	# Now, for the found scripts, check the servers part and match it against it's $reg_server
	my $matches = 0;
	for my $script (@REG_SCRIPTS) {
		@REG_SERVERS = ();
		my ( $reg_script, $reg_server ) = split /=/, $script, 2;
		next unless $reg_server;    # skip files that do not have servergroup candidates
		globlize($reg_server);
		say "For $script, search for servers: $reg_server in $serversdir argv:($argv)"
		  if $CFG{'DEBUG'};
		if($last_only){
			push( @REG_SERVERS, map basename($_->[0]),
			sort { $b->[1] <=> $a->[1] } map [ $_, +(stat $_)[9] ],
			grep $_ ne '.' && $_ ne '..', glob( $serversdir . '/' . '*' ) );
			$scripts = $REG_SERVERS[0] || "";
		}else{
			push( @REG_SERVERS, map { basename($_) } glob( $serversdir . '/' . $reg_server ) );
		}
		warn "No server files found that match $CFG{'SERVERS'}/$reg_server\n"
		  unless @REG_SERVERS || !$CFG{'WARNINGS'};

		# And for that real server string representing a file, match our pattern $scripts
		for my $server (@REG_SERVERS) {
			my $scriptserver = $script;
			$scriptserver =~ s/=\K.*/$server/;
			my $scriptsreg = $scripts;
			globlize($scriptsreg);
			$scriptsreg =~ s/([\*\?])/.$1/g;    # glob-regexp to perl-regexp
			my $is_match = $scriptserver =~ /$scriptsreg/;
			++$matches if $is_match;
			say
"check FIT argv: $argv script: $script scripts:$scripts\n scriptsreg: $scriptsreg scriptserver: $scriptserver\n"
				. " server=$server  $scriptserver =~/ $scriptsreg / matches=$is_match"
				if $CFG{'DEBUG'};
			++$SCRIPT_FILES{ $suit . ':' . $script }{ $suit . ':' . $server } if $is_match;

			if ($hoststr) {
				# TODO: give it a pointer to where $hoststr has regexp (split /,/)
				@{ $SCRIPT_FILES{ $suit . ':' . $script }{'!'} } = split /,/, $hoststr;
			}
		}
	}
	warn "No scripts and server files found for $scripts ($argv)\n"
		if ( @REG_SCRIPTS && !$matches && $CFG{'WARNINGS'} );
	%SCRIPT_FILES;
}

# Each argument can give us a combination test+servers, so we unite the list (to remove duplicates)
for my $argv (@ARGV) {

	# Should the argument have come quoted and is more than one, then split and add it to the loop
	$argv = unalias($argv);
	if ( index( $argv, ' ' ) > -1 ) {
		push @ARGV, split / +/, $argv;
		next;
	}

	say "Processing ARG: $argv" if $CFG{'VERBOSE'};

	# Redefine commandline
	if($argv=~s/^&//){
		push @{$CFG{'REDEFINE'}}, $argv;
		&redefine();
		next;
	}

	# Replace =# with the -l loop serverscripts (can be comma separated)
	if(defined $BASECFG{'LOOP'}){
		my $svrs = join ",", @{$BASECFG{'LOOP'}};
		grep s/=\K#/$svrs/e,$argv;
	}

	%CFG = UnDeepCopy( \%_CFG ) if $#ARGV;    # only restore if more than one test
	my ( $suit, $scripts, $hoststr ) = getSuitAndScriptsAndHostStr($argv);
	if ( !$hoststr ) {
		if ( $CFG{'UNFOLD'} ) {
			$hoststr = '.';
		} else {
			$hoststr = "";
		}
	}
	say "Processing: suit($suit) scripts($scripts) hoststr($hoststr)" if $CFG{'VERBOSE'};

	my %SCRIPT_FILES = getscripts( $suit, $scripts, $hoststr, $argv );

# Now loop over all scripts and make sure they do not overlap tests. For example, say:
# You have test1=VM+ and test1=VM-ET, so the servergroup VM-ET matches both, clearly it is better to run test1=VM-ET
	if ( !$CFG{'NOAUTOFIX'} ) {
		my %TEST2SCRIPT;
		for my $suitscript ( sort keys %SCRIPT_FILES ) {
			my ( $test, $server ) = split /=/, $suitscript, 2;
			push @{ $TEST2SCRIPT{$test} }, $suitscript;
		}
		for my $test ( sort keys %TEST2SCRIPT ) {
			my %SEEN;
			for my $suitscript ( sort { length($b) <=> length($a) || $a cmp $b }
				( @{ $TEST2SCRIPT{$test} } ) ) {
				for my $servergroup ( grep { !/^!$/ } keys %{ $SCRIPT_FILES{$suitscript} } ) {
					if ( $SEEN{ $test . '=' . $servergroup }++ ) {
						$SCRIPT_FILES{$suitscript}{$servergroup} = 0;
					}

				}
			}
		}
	}
	if ( $CFG{'DEBUG'} ) {
		no warnings;
		say "DEBUG: Variables list";
		updateTime( \%CFG );
		$CFG{N} += 1;    # simulate %{N} being set somewhat correctly.
		for my $key ( sort keys %CFG ) {
			print " \%{$key}=";
			if( $_ = ref($CFG{$key}) ){
				if($_ eq "HASH"){
					print join(", ", map { "$_ -> $CFG{$key}{$_}" } keys %{$CFG{$key}});
				}elsif($_ eq "ARRAY"){
					print join ":", @{$CFG{$key}}
				}
				say "";
			}else{
				my $v = $CFG{$key};
				$v =~s/\033/\\033/g;
				say $v;
			}
		}

		for my $key1 ( sort keys %SCRIPT_FILES ) {
			for my $key2 ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$key1} } ) {
				say "DEBUG: WOULD RUN $SCRIPT_FILES{$key1}{$key2} == $key1 => $key2";
			}
		}
	}

	for my $suitscript ( sort keys %SCRIPT_FILES ) {
		my ( $suit, $script ) = split ":", $suitscript, 2;
		my $scriptsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
		$CFG{'RUNSCRIPTSDIR'} = $scriptsdir = abs_path $scriptsdir;
		my $resultsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'RESULTS'};
		$CFG{'RUNRESULTSDIR'} = $resultsdir = abs_path $resultsdir;
		for my $suitserver ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$suitscript} } ) {
			if ( $SCRIPT_FILES{$suitscript}{$suitserver} == 0 ) {
				say "SKIPPING $suitscript $suitserver ($SCRIPT_FILES{$suitscript}{$suitserver})"
				  if $CFG{'DEBUG'};
				next;
			}
			my ( $suit, $server ) = split ":", $suitserver, 2;
			my $serversdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SERVERS'};
			$CFG{'RUNSERVERSDIR'} = $serversdir     = abs_path $serversdir;
			$CFG{'RUNSUIT'}       = $suit;
			$CFG{'RUNNAME'}       = $CFG{'RUNSCRIPT'} = $script;
			$CFG{'RUNNAME'} =~ s/=.*//;
			$CFG{'RUNSERVER'}   = $server;
			$CFG{'RUNSCRIPTFQ'} = $CFG{'RUNSCRIPTSDIR'} . '/' . $CFG{'RUNSCRIPT'};
			$CFG{'RUNSERVERFQ'} = $CFG{'RUNSERVERSDIR'} . '/' . $CFG{'RUNSERVER'};

			if ( $CFG{'UNFOLD'} && !defined $RICH{ $CFG{'RUNSERVERFQ'} } ) {
				if ( !defined $RICH{ $CFG{'RUNSERVERFQ'} } ) {

			# read file if we havent done so, and check if it contains nested files, or sidecomments
					readfiletoarray( $CFG{RUNSERVERFQ} );

					if ( $CFG{'UNFOLDED'} || $CFG{'RICH'} ) {
						$RICH{ $CFG{'RUNSERVERFQ'} } = 1;
					} else {
						$RICH{ $CFG{'RUNSERVERFQ'} } = 0;
					}
				}
				push @{ $SCRIPT_FILES{$suitscript}{'!'} }, '.' if $RICH{ $CFG{'RUNSERVERFQ'} };
			}

			if ( defined $SCRIPT_FILES{$suitscript}{'!'} ) {
				say "###$script:opening $CFG{RUNSERVERFQ} for $CFG{RUNSCRIPTFQ}" if $CFG{'DEBUG'};
				my @read_servers = readfiletoarray( $CFG{'RUNSERVERFQ'} );
				my @servers;
				my $counter = 0;
				while ( $_ = shift @read_servers ) {
					chomp;
					my $found = 0;
					++$counter;
					for my $regexp ( @{ $SCRIPT_FILES{$suitscript}{'!'} } ) {
						say "looking if $_ matches $regexp" if $CFG{'DEBUG'};
						if (
							$regexp =~ /^#(\-?\d+)/
							? ( $1 > 0 ? $counter == $1 : $#read_servers + 2 == -$1 )
							: m/$regexp/ix
						) {
							s/\s+.*//;
							push @servers, $_;
							last;
						}
					}
				}

				say "Filter(\@) matched "
				  . ( $#servers + 1 )
				  . " out of $counter from $CFG{RUNSERVERFQ} UNFOLDED=$CFG{'UNFOLDED'} RICH=$CFG{'RICH'} UNFOLD=$CFG{'UNFOLD'} ~> $RICH{$CFG{RUNSERVERFQ}}"
				  if $CFG{'DEBUG'};
				next unless @servers;    # no matches, skip this test
				     # only create a temporal file if we do not match ALL servers in this group.
				if ( $#servers + 1 < $counter || $RICH{ $CFG{'RUNSERVERFQ'} } ) {
					my $tempfile =
					    ( $suit eq ".." ? '_' : $suit ) . '#'
					  . $script . '#'
					  . $server . '#'
					  . $CFG{PID};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSERVERFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					$CFG{'RUNSERVERSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSERVER'} = $server = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSERVERFQ'} ) or abort("$CFG{RUNSERVERFQ}: $!");
					say $FOUT $_ for @servers;
					close $FOUT;
				}
			}

			# enquote
			if ( $CFG{'QUOTE'} ) {
				for my $fq (qw(RUNSCRIPTFQ RUNSERVERFQ)) {
					$CFG{$fq} =~ s/($CFG{QUOTESTR})/\\$1/g;
					$CFG{$fq} = $CFG{'QUOTESTR'} . $CFG{$fq} . $CFG{'QUOTESTR'};
				}
			}

			if ( $CFG{'FOLD'} || $CFG{'GROUP'} || $CFG{'BUNDLE'} ) {
				say "Defering execution("
				.($CFG{'FOLD'}?'F':'f')
				.($CFG{'GROUP'}?'G':'g')
				.($CFG{'BUNDLE'}?'B':'b')
				."): $CFG{'RUNSCRIPT'} on $CFG{'RUNSERVER'}" if $CFG{'DEBUG'};
				$DEFER{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }++;
				%{$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }} = UnDeepCopy(\%CFG) unless $CFG{'GROUP'};
				%{$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{'_'}} = UnDeepCopy(\%CFG);
				push @DEFERARR, $CFG{'RUNSCRIPTFQ'}  unless (grep $_ eq $CFG{'RUNSCRIPTFQ'}, @DEFERARR);
			} else {
				$CFG{'RUNNAMES'} = $CFG{'RUNNAME'};
				&executerun();
			}
		}
	}
}

# If running actions were defered (because of folding/grouping/bundling), run them now
if (%DEFER) {

	if ( $CFG{'GROUP'} ) {
		for my $script ( keys %DEFER ) {
			my $str = join $CFG{'SEPARATOR'}, sort keys %{ $DEFER{$script} };
			undef $DEFER{$script};
			$DEFER{$script}{"$str"} = 1;
		}
	}

	if ( $CFG{'FOLD'} ) {
		my %FOLD;
		for my $k ( keys %DEFER ) {
			for my $v ( keys %{ $DEFER{$k} } ) {
				$FOLD{$v}{$k} = 1;
			}
		}
		%DEFER = ();
		for my $k ( keys %FOLD ) {
			my $str = join $CFG{'SEPARATOR'}, sort keys %{ $FOLD{$k} };
			$DEFER{$str}{$k} = 1;
		}
	}
	$CFG{'RUNNAMES'} = join '+', grep { s{.*/}{}; s{=.*}{}; } sort keys %DEFER;

	for my $scripts ( $CFG{'FOLD'}? sort keys %DEFER : @DEFERARR) {
		$CFG{'RUNSCRIPTFQ'} = $scripts;
		for my $servers ( sort keys %{ $DEFER{$scripts} } ) {
			$CFG{'RUNSERVERFQ'} = $servers;

			if ( $CFG{'BUNDLE'} ) {
				if ( index( $scripts, $CFG{'SEPARATOR'} ) > -1 ) {
					my $tempfile =
					    ( $CFG{'RUNSUIT'} eq ".." ? '_' : $CFG{'RUNSUIT'} )
					  . '#BUNDLESCRIPTS#'
					  . $CFG{'N'} . '#'
					  . $CFG{'PID'};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSCRIPTFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					say "# BUNDLING SCRIPTS $scripts" if $CFG{'VERBOSE'};
					$CFG{'RUNSCRIPTSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSCRIPT'}     = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSCRIPTFQ'} ) or abort("$CFG{RUNSCRIPTFQ}: $!");
					for my $file ( split /$CFG{'SEPARATOR'}/, $scripts ) {
						say "## BUNDLING SCRIPT $file" if $CFG{'DEBUG'};
						say $FOUT $_ for readfiletoarray($file);
					}
					close $FOUT;
				}

				if ( index( $servers, $CFG{'SEPARATOR'} ) > -1 ) {
					my $tempfile =
						( $CFG{'RUNSUIT'} eq ".." ? '_' : $CFG{'RUNSUIT'} )
						. '#BUNDLESERVERS#'
						. $CFG{'N'} . '#'
						. $CFG{'PID'};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSERVERFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					say "# BUNDLING SERVERS $servers" if $CFG{'VERBOSE'};
					$CFG{'RUNSERVERSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSERVER'}     = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSERVERFQ'} ) or abort("$CFG{RUNSERVERFQ}: $!");
					for my $file ( split /$CFG{SEPARATOR}/, $servers ) {
						say "## BUNDLING SERVER $file" if $CFG{'DEBUG'};
						say $FOUT $_ for readfiletoarray($file);
					}
					close $FOUT;
				}
			}

			my $scriptfq = $CFG{'RUNSCRIPTFQ'};
			my $serverfq = $CFG{'RUNSERVERFQ'};
			my $script = $CFG{'RUNSCRIPTFQ'};
			my $server = $CFG{'RUNSERVERFQ'};
			$script =~ s{$CFG{'RUNSCRIPTSDIR'}/}{}g;
			$server =~ s{$CFG{'RUNSERVERSDIR'}/}{}g;
			%CFG = %{$_} if defined ($_=$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }) 
				|| defined ($_=$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ '_' });
			$CFG{'RUNSCRIPT'} = $script;
			$CFG{'RUNSERVER'} = $server;
			$CFG{'RUNSCRIPTFQ'} = $scriptfq;
			$CFG{'RUNSERVERFQ'} = $serverfq;
			&executerun();
		}
	}
}

# Remove all temporal files, unless KEEP is set
if ( !$CFG{'KEEP'} ) {
	for my $tmpfile ( @{ $CFG{'_CLEANUP'} } ) {
		say "removing temporal file $tmpfile" if $CFG{'VERBOSE'};
		unlink $tmpfile;
	}
}

runit('RUN_END') if $BASECFG{'RUN_BEGAN'};
runit('RUN_FINISH');
exit 0;

# Expand ALIAS variables in the parameters
sub unalias
{
	my ($str) = @_;
	if ( index( $str, '@' ) > -1 ) {
		my ( $expr1, $expr2 ) = split( '@', $str, 2 );
		$expr1 =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
		$str = $expr1 . '@' . $expr2;
	} else {
		$str =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
	}
	return $str;
}


sub executerun
{
	if ( $CFG{'ARG'} ) {
		if ( ref $CFG{'ARG'} eq "ARRAY" ) {
			$CFG{'ARG'} = join " ", @{ $CFG{'ARG'} };
		}
	}
	if ( $CFG{'VERBOSE'} ) {
		say "# RUN($CFG{'ARGV'}) $CFG{RUNSUIT}:$CFG{RUNSCRIPT} on $CFG{RUNSERVER}"
		  . ( $CFG{'ARG'} ? " with argument '$CFG{ARG}'" : "" );
		say "# SCRIPT=$CFG{RUNSCRIPTFQ}";
		say "# SERVER=$CFG{RUNSERVERFQ}";
	}
	$CFG{'N'} = $BASECFG{'N'} += 1;    # Unique counter %{N} (combine with %{PID} to create tempfiles)
	my $EC;
	my $REDO = defined $CFG{'REDO'} ? $CFG{'REDO'} : 0;
	for my $run ( glob "{RUN}{_PRE,,_POST}{_TEST,}" ) {
		next if $run =~ /_TEST$/ && !defined $CFG{'TEST'};
	  REDO:
		if ( $CFG{'ARG'} && defined $CFG{ $run . "_ARG" } ) {
			$EC = runit( $run . "_ARG", $run ne "RUN_PRE" );    # update time only for RUN_PRE
		} else {
			$EC = runit( $run, $run ne "RUN_PRE" );             # update time only for RUN_PRE
		}
		if ( $EC && $REDO > 0 && $run eq "RUN" ) {
			--$REDO;
			goto REDO;
		}
		last if ( $EC && $run =~ /_TEST|RUN_PRE/ );
	}
}

# allow executing ABORTMSG before die (usually from lacking permissions to read/write files)
sub abort
{
	$CFG{'ABORTMSG'} = $_[0];
	runit('RUN_ABORT');
	die $_[0] . "\n";
}

# Run (or dryrun) the commands defined as RUN... in the cfg file
sub runit
{
	my ( $KEY, $no_time_update ) = @_;
	if ( $_ = $CFG{$KEY} ) {
		updateTime( \%CFG ) unless $no_time_update;
		if(index( $_, "%{" ) > -1){
			xexpand( $_, '%\{(\w+)\}', \%{ $CFG{'ALIAS'} } ) ;
			xexpand( $_, '%\{([\w:]+)\}', \%CFG )
		}
		if(index( $_, "\${" ) > -1 && !$CFG{'DRYRUN'}){
			xexpand( $_, '\$\{(\w+)\}', \%{ $CFG{'ALIAS'} }, '$' ) ;
			xexpand( $_, '\$\{(\w+)\}', \%CFG, '$' )
		}

		if ( $CFG{'DRYRUN'} ) {
			say "# RUN_BEGIN:\n" . $CFG{'RUN_BEGIN'}
			  if ( defined $CFG{'RUN_BEGIN'} && !$BASECFG{'RUN_BEGAN'}++ );
			say "# $KEY:\n" . $_;
		} else {
			if ( $KEY ne 'RUN_START' && defined $CFG{'RUN_BEGIN'} && !$BASECFG{'RUN_BEGAN'}++ ) {
				my $__ = $_;
				$CFG{'_'}=$CFG{'RUN_BEGIN'};
				$CFG{'__FAIL'}=$CFG{'RUN_BEGIN_FAIL'} if defined $CFG{'RUN_BEGIN_FAIL'};
				runit('_',1);
				delete @CFG{qw(_ __FAIL)};
				$_ = $__;
			}
			say $_ if $CFG{'VERBOSE'};
			my $ec = system $_;
			say " # ExitCode=$?" if $CFG{'VERBOSE'};
			$CFG{'TOTALERRORS'} = $BASECFG{'TOTALERRORS'} += 1 if $CFG{'ERRORCODE'} = $ec >> 8;
			runit( $KEY . "_FAIL", 1 ) if ( $ec && $KEY !~ /_FAIL$/ && $CFG{ $KEY . "_FAIL" } );
			return $ec;
		}
	}
	return $CFG{'ERRORCODE'} = 0;
}

# transform lazy search into a glob-able pattern
sub globlize
{
	$_[0] =~ s/^(\+\+)|(=\K\+\+)|(\+\+)$/$1||$2?"*-":"-*"/ge;    # ++ to *
	while ( $_[0] =~ s/\+\+|\-\-/-*-/g ) { }                     # ++ to -*-
	$_[0] =~ s/\+/\*/g;                                          # all other + to *
	$_[0] =~ s/^\-/\*-/g;                                        # if starts with -, then *-
	$_[0] =~ s/\-$/-\*/g;                                        # if ends with -, then  -*
}

# xexpands %{} or ${} variables
sub xexpand
{
	if($_[3]){
		$_[0] =~ s/$_[1]/defined($_[2]{$1})?$_[2]{$1}:"\${$1}"/ge;
	}else{
		$_[0] =~ s/$_[1]/defined($_[2]{$1})?$_[2]{$1}:"%{$1}"/ge;
	}
	$_[0];
}

# Time variables exposed to CFGFILE
sub updateTime
{
	my ( $v, $e ) = @_;
	$v->{"EPOCH"} = $e = ( $e || time );
	my @T = $CFG{'UTC'} ? gmtime($e) : localtime($e);    # S M H d m+1 y+1900 wd yd daylightsaving
	$v->{"HH"} = $T[2] < 10 ? '0' . $T[2] : $T[2];     # hour (00..23)
	$v->{"MM"} = $T[1] < 10 ? '0' . $T[1] : $T[1];     # minute (00..59)
	$v->{"SS"} = $T[0] < 10 ? '0' . $T[0] : $T[0];     # seconds (00..23)
	$v->{"WD"} = $T[6] || 7;                           # 1=Monday ... 6=Saturday, 7=Sunday
	$v->{"YD"} = sprintf( "%03d", $T[7] + 1 )
	  ;    # day of the year, in the range 001..365 (or 001..366 if leap year)
	$v->{"DAY"}   = $T[3] < 10   ? '0' . $T[3] : $T[3];    # day of the month
	$v->{"MONTH"} = ++$T[4] < 10 ? '0' . $T[4] : $T[4];    # 01=jan ... 12=dec
	$v->{"YEAR"} = $T[5] + 1900;                           # 4 digits year
	$v->{"DS"}   = $T[8];                                  # daylightsaving

	$v->{"TOTALTIME"} = time - $^T;                        # total seconds running
}

# use $_recursed=-1 to read verbatim
sub readfiletoarray
{
	my ( $_file, $_recursed, $_filter ) = @_;
	say "readfiletoarray($_file,$_recursed,$_filter)" if $CFG{'DEBUG'};
	$CFG{'UNFOLDED'} = $CFG{'RICH'} = 0 unless $_recursed;
	open( my $FIN, '<', $_file ) or abort("$_file: $!");
	my @_SVRS;
	while (<$FIN>) {
        next if defined $_filter && ! /$_filter/;
		chomp;
		if (defined($_recursed) && $_recursed>-1 && /\//) {
			$CFG{'UNFOLDED'}++;    # signal that we unfolded
			s{^\.}{%{SUITSDIR}/%{SUIT}/%{SERVERS}};
			$_ = xexpand( $_, '%\{(\w+)\}', \%CFG ) if index( $_, "%{" ) > -1;
			push @_SVRS, readfiletoarray( $_, 1 , $_filter||undef);
		} else {
			$CFG{'RICH'}++ if /\s/;    # signal we have a commented hostfile
			push @_SVRS, $_;
		}
	}
	close($FIN);
	@_SVRS;
}

# 1 level deeper hash copy
sub UnDeepCopy
{
	my %COPY;
	my $ORG = $_[0];
	my $typeof;
	for my $k ( keys %$ORG ) {
		$typeof = ref( $$ORG{$k} );
		if ( !$typeof ) {
			$COPY{$k} = $$ORG{$k};
		} elsif ( $typeof eq 'ARRAY' ) {
			@{ $COPY{$k} } = @{ $$ORG{$k} };
		} elsif ( $typeof eq 'HASH' ) {
			%{ $COPY{$k} } = %{ $$ORG{$k} };
		}
	}

	%COPY;
}

sub getdir
{
	opendir( my $dh, $_[0] ) || die "Can't opendir $_[0] $!";
	my @list = grep {! /^\./} readdir($dh);
	closedir $dh;
	@list;
}

sub redefine
{
	my $n=-1;
	#@{ $CFG{'REDEFINE'} } = grep defined, @{ $CFG{'REDEFINE'} }; # remove undef elements
	for my $redef ( @{ $CFG{'REDEFINE'} } ) {
		++$n;
		next unless defined $redef;
		$redef=~s/^\s+|\s+$//g; # trim
		next unless $redef;
		my $_redef = $redef;
		if ( index( $redef, '=' ) == -1 ) {
			# for: ./evidencer -r NORUN,NOPRE
			if ( index( $redef, "," ) > -1 ) {
				push @{ $CFG{'REDEFINE'} }, split /,/, $redef;
				$CFG{'REDEFINE'}->[$n]=undef;
				next;
			}
			# if no = to assign, then it must be an alias, substitute it.
			$_redef =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
		}
		# different commands are split by {,}
		if ( index( $_redef, "{,}" ) > -1 ) {
			push @{ $CFG{'REDEFINE'} }, split /\s*{,}\s*/, $_redef;
			$CFG{'REDEFINE'}->[$n]=undef;
			next;
		}
		# now they are in the form: variable=value, split and assign to %CFG
		$_redef =~ s/^&//; # to allow for argument and parameter aliases to work
		@_ = split /=/, $_redef, 2;
		say "# redef=($redef)" if $CFG{'DEBUG'};
		if ( defined $_[1] && index( $_[1], "%{" ) > -1 ) {
			xexpand( $_[1], '%\{(\w+)\}', \%CFG );
		}
		if($_[0]=~s/!$//){
			++$DONOTOVERRIDE{ $_[0] };
			# $BASECFG{ $_[0] } = $_[1]; 
		}
		$_CFG{ $_[0] } = $CFG{ $_[0] } = $_[1];
	}
}
__END__

=head1 NAME

evidencer.pl - A program to run scripts on servers

For the full help, see README.md or directly on L<github|https://github.com/FBnil/evidencer>

=head1 DESCRIPTION

 evidencer [-s <suit>] [suit:][script]=[servergroup][@<hostnames_regexp,...|#n>] [--help] [--man]
 
 
 Example:

 # Run, from the suit JAVATRANSACTIONS the test JAVASERVER-SERVICES= for servers JAVA-ET
 # that match the perl regexp javaserver00[1..5] or the substring javaserver0100
 ./evidencer JAVATRANSACTIONS:JAVASERVER-SERVICES=JAVA-ET@javaserver00[1..5],javaserver0100

 # show (dryrun) what would run from the suit JAVATRANSACTIONS the test
 # JAVASERVER-SERVICES= for any matching servers AND the test JAVASERVER-PORTS for any of it's
 # matching servers
 ./evidencer -s JAVATRANSACTIONS JAVASERVER-SERVICES=* JAVASERVER-PORTS -d

 JAVASERVER-SERVICES=* can be written as:
   JAVASERVER-SERVICES=  or as  JAVASERVER-SERVICES=+  or even as  JAVASERVER-SERVICES

 The servergroup part of a script name, uses a plus sign instead of an asterix, and these are the transformation rules:
 +     ==>  *       ++    ==>  *-*     +-+-+ ==>  *-*-*
 +A    ==>  *A      A+    ==>  A*      ++B   ==>  *-B
 +-A   ==>  *-A     A-+   ==>  A-*     A++   ==>  A-*
 A++B  ==>  A-*-B   A-+B  ==>  A-*B    A+-B  ==>  A*-B

 So if you have a servergroup called APACHE-PROD-DMZ, then =++DMZ would match that group.
 And ++PROD++  would match *-PROD-*. These are glob expansions, which means it would match
 exactly what ls would match if you run:  ls ./servers/*-PROD-*

 If unsure, escape or quote your servergroup and use dryrun.

 @hostnames regexp's are not un-ALIAS-ed.
 
 You must have a configuration file that tells evidencer what to do with the script and the servergroup. So it at least needs a RUN= statement in that configuration file.


=head1 DIRECTORIES

./servers/  Define a list of server by function.

./scripts/  Define a list of tests, by function, to be run on those servers

./results/  Just an empty directory to store results in (from an external program)

./suits/    Once you are done with your tests, move them away into a suit, still available

./tmp/      A temporal directory to hold sub lists of servergroups when using hostnames_regexp

to create the top-level directories use the following command: 

./evidencer -s .. -C

To create a suits directory structure:

./evidencer -C -s MYAPPL

Note: You can edit evidencer.cfg beforehand to redefine these directory names. See section CONFIGURATION

=head1 CONFIGURATION Variables

There are 3 level of configuration files: the toplevel, evidencer.cfg, then inside a suit, also
named evidencer.cfg, and then per script, the name of the script up to the = and then .cfg


=over 10

=item B<BASEDIR>

The directory where the evidencer binary is located

=item B<CFGDIR>

Configuration directory Defaults to cfg. Can only be defined in the toplevel configuration file (not inside suits). Can place your cfg files in a subdirectory of the SUIT, if you prefer that.

      
=item B<TEMP>

The directory where temporal files are created. Temporal files are needed when you use @hostnames_regexp, because we need a subset of servers from the content of the servergroup file. The default is a ./temp/ subdirectory where the evidencer script is located.

=item B<SUITSDIR>

The directory where are the suit directories are in. The default is a ./suits/ subdirectory where the evidencer script is located.

=item B<SUIT>

Defaults to .. this way, you do not need to worry about having a suit directory, you'll have ./servers/ and ./scripts/here in the same directory evidencer resides

=item B<SERVERS>

If for some reason, you want the ./servers/ directory name to be different, you can override this name. The default is SERVERS=servers

=item B<SCRIPTS>

If for some reason, you want the ./scripts/ directory name to be different, you can override this name. For example, to use ssh-batch. That program uses inline as the directory name. The default is SCRIPTS=scripts

=item B<RESULTS>

Just a directory where the results are to be kept. The default is RESULTS=results

=item B<ALIAS>

You can define multiple aliases. The suit and the script in the commandline parameters are un-aliased. The hostnames_regexp is not. Example: ALIAS ES=ELASTICSEARCH


=back


=head1 RUN variables

All variables that have to do with running found combinations of servers and scripts


=over 13

=item B<PID>

The process ID of the currently running evidencer use it as: %{PID}. Combine with %{N} for unique filenames

=item B<ARGV>

The script+server combination we are running

=item B<ARG>

Contains the string with the argument(s) passed with -- or a single argument passed with -a

=item B<N>

A number that increases just before you use the: RUN_PRE, RUN and RUN_POST. Use it like: %{N}.
If not using FOLD nor GROUP it's the number of scripts ran so far.

=item B<RUNSCRIPTSDIR>

The directory where the scripts are located, basically: %{SUITSDIR}/%{SUIT}/%{SCRIPTS}

=item B<RUNSERVERSDIR>

The directory where the servergroups are located, basically: %{SUITSDIR}/%{SUIT}/%{SERVERS}

=item B<RUNSUIT>

The currently running suit

=item B<RUNSCRIPT>

The name of the scripts file being processed

=item B<RUNSERVER>

The name of the servers file being processed

=item B<RUNSCRIPTFQ>

Fully Qualified name for the scripts file, basically: %{RUNSCRIPTSDIR}/%{RUNSCRIPT}

=item B<RUNSERVERFQ>

Fully Qualified name for the servers file, basically: %{RUNSERVERSDIR}/%{RUNSERVER}

=item B<RUNNAME>

The name of the scripts file being processed %{RUNSCRIPT}, but stripped of the = and everything to the right

=item B<RUNNAMES>

If you --bundle or --fold you might want to use the + concated scripts names, instead of RUNNAME which will contain only the last one

=item B<TEST>

Argument string given with --test on the commandline (available as %{TEST}). It can be used in your RUN_PRE_TEST or RUN_TEST (and RUN_POST_TEST), which only activate when --test is used

=item B<RUN_PRE_TEST>

Execute this string in the shell to test the validity of the script+server combination. As with all *_TEST, Exit nonzero to skip execution of RUN_PRE and all after

=item B<RUN_PRE>

Execute this string in the shell. Runs before RUN. Time date strings are set before RUN_PRE and are the same for RUN and RUN_POST even if they take time to execute. Exit nonzero to skip.

=item B<RUN_TEST>

Execute this string in the shell to test the validity of the script+server combination. Exit nonzero to skip RUN (but RUN_PRE already ran if it was defined)

=item B<RUN>

Execute this string in the shell

=item B<RUN_POST>

Execute this string in the shell. Runs after RUN

=item B<KEEP>

Set to true(1) to keep temporal files created when @hostnames is used

=item B<RUN_START>

This always runs at the beginning

=item B<RUN_BEGIN>

Run just before the first RUN_PRE is ran. If no scripts+servers is matched, then this does not trigger

=item B<RUN_END>

Runs at the very end of each evidencer script, only if RUN_BEGIN ran (%{RUN_BEGAN} is nonzero)

=item B<RUN_FINISH>

This always runs at the end. It has access to a number %{N} if it is zero, nothing actually ran

=item B<ABORTMSG>

The fatal errormessage will be available to RUN_ABORT to do something with it (for example:log it)

=item B<RUN_ABORT>

Execute this string in the shell when a fatal error occurred: When evidencer could not read or create a file it needs to run



=back

All RUN* commands have a *_FAIL counterpart. If the exitcode of the command is nonzero, then the *_FAIL will be run. The RUN_PRE is a special case: when RUN_PRE returns with a nonzero exitcode, then RUN_PRE_FAIL will also run, but then the rest, like RUN and RUN_POST will be skipped. To override this, end your RUN_PRE command with ;true.

If you use arguments (either by adding a single argument with -a or using -- at the end of the parameters, and adding your parameter(s) after it; then, if you have defined: RUN_PRE_TEST_ARG, RUN_PRE_ARG, RUN_TEST_ARG, RUN_ARG, RUN_POST_TEST_ARG, RUN_POST_ARG Then those commands will be used instead. In both cases, %{ARG} will be available to be used.

So the order is: RUN_START, RUN_BEGIN, RUN_PRE_TEST, RUN_PRE, RUN_TEST, RUN, RUN_POST_TEST, RUN_POST, RUN_END, ...(next test)... RUN_FINISH. and a *_FAIL f

or each of these and a RUN_ABORT when file IO fails.



=head1 OPTIONS

 [OPT         DESCRIPTION]

 -h | --help | -?   Print Options and Arguments.
 --man              Print complete man page.
 -v | --verbose     Log more to the screen
 -D | --DEBUG       Log a bit more to the screen
 -d | --dryrun      Do not execute, but show all that would have been run
 -U | --UTC         timestrings are in UTC instead of localtime
 -C | --CREATEDIRS  Create directories if they do not exist
 -c | --config <cfg> Read alternative cfg file
 -k | --keep        Do not cleanup temporal files created to accomodate the @hostnames list
 -n | --noautofix   Do not skip running tests on servergroups that match multiple tests
 -u | --unfold      If you have files in your servergroups, recursively read the servers.
 -f | --fold        Group by Scripts
 -g | --group       Group by Servergroups
 -b | --bundle      Concatenate all scripts/servers if they are folded or grouped, into a new file
 -r | --redefine  $ Override a variable from evidencer.cfg (can be used multiple times)
 -a | --argument  $ Quick redefine that sets %{ARG} for use in RUN*_ARG scripts (if defined).
 -q | --quote       Quote your scripts and servers using %{QUOTESTR}. Handy for fold and group.
 -S | --SEPARATOR $ The separation characters between folded and grouped items. (default is double space)
 -t | --test  <$>   Final test against a RUN (either before or after RUN_PRE) to validate the combination
 -s | --suit <suit> Only consider this suit for all script-server matches
 -w | --warnings    Enable warnings when your script=server combination does not match anything. 
                    Set WARNINGS=1 in the configuration file to enable it by default
 -o | --on <host>   Comma separated list of hosts (will create a serverfile for you) for =#
 -l | --loop <$>    Loop on comma separated list of serverfiles for =#
 --query <var>      Prints the value of a variable defined in your evidencer.cfg and exits

Options can be anywhere in the commandline (but not after the `--` parameter). Options can be shortened (1st letter) and can be bundled.

=head1 SCRIPTS HELP

The scripts can have lines that start with #: (vieable with -h) or #+: (vieable with -hv)
For example:
./evidencer spoon -hv

If you are making your own help text inside scripts, then you can add colors with <C>, 
where C is a character, or a number. The available characters are viewable with:
B<grep C: evidencer |grep 033 |grep =>

If you do not want colors, use NOCOLORS, like so:

./evidencer . -hv -r NOCOLORS=2

You can put this variable also in your evidencer.cfg file:

# NOCOLORS=     # default. Display help with colors

# NOCOLORS=1    # Only headers are bold, the rest is monochromatic

# NOCOLORS=2    # fully monochromatic, useful for storing in a text file.

=head1 TAB EXPANSION

You can activate tab expansion for evidencer by putting the following in your ~/.bashrc:

./evidencer --complete >> ~/.bashrc

(and when you do that for the first time, source your bashrc first, or open a new terminal)

If you do not want to change your .bashrc, then run this to get tab expansion in your current terminal:

eval $(./evidencer --complete)

Sometimes expansion does not work, check that there is no other expansion for the binary defined:

`complete |grep evidencer` and delete it with `complete -r evidencer` then try again.


Tip: the newest file in ./servers/ is aliased to #, so to run a script on all the server in that latest file:

./evidencer os.show.boottime=#

=head1 LICENSE AND COPYRIGHT

This software is released under the Unlicense statement.
It is free and unencumbered software released into the public domain.
If you don't know what that means visit L<https://unlicense.org/>.

=cut
