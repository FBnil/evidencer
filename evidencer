#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case no_getopt_compat); # https://perldoc.perl.org/Getopt::Long.txt
Getopt::Long::Configure("bundling");
BEGIN {no warnings; $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
use Pod::Usage qw( pod2usage );
use File::Basename qw(dirname basename fileparse fileparse_set_fstype);
use Cwd qw(abs_path getcwd);
use feature 'say';

my $VERSION = '1.0r183';
my $CFGFILE;
my %DEFER;    # for GROUP or (UN)FOLD
my @DEFERARR; # Keep the execution order as much as possible
my %CFGSTOR;
my %RICH;     # for forcing a new servergroup file
my %CFG;      # Variable configuration
my %_CFG;     # BASE configuration
my $MELINKED = -l $0;    # holds if the current file is a symlink (changes behavior)
my $me; # holds my absolute filename
{
	my $lnk = $MELINKED? readlink($0) : '';
	my $abslnk = $lnk =~m{^/};
	$me = dirname( abs_path( $MELINKED ? ($abslnk? '' : dirname($0).'/').$lnk : $0 ) ) . '/' . basename($0);
}


our %BASECFG  = (
	PID       => $$,
	N         => 0,
	UTC       => 0,
	NEWLINE   => "\n",
	SEPARATOR => "  ",
	ARG       => undef,
	QUOTESTR  => "'",
	CFGDIR    => "",
	TOTALERRORS => 0,
	# COLORS
	'C:'  => "\033[0m", # Normal
	'C:N' => "\033[0m", # Normal
	'C:B' => "\033[1m", # BOLD
	'C:I' => "\033[3m", # ITALIC
	'C:U' => "\033[4;37m", # UNDERLINE
	'C:K' => "\033[2;30m", # BLACK
	'C:R' => "\033[1;31m", # RED
	'C:G' => "\033[1;32m", # GREEN
	'C:Y' => "\033[1;33m", # YELLOW
	'C:L' => "\033[1;34m", # BLUE
	'C:P' => "\033[1;35m", # PURPLE (officially Magenta)
	'C:C' => "\033[1;36m", # CYAN
	'C:W' => "\033[1;37m", # WHITE
	'C:A' => "\033[2;37m", # GRAY
	'C:Z' => "\033[7;1m", # INVERT
	'C:O' => "\033[38;5;208m", # ORANGE (might not be available on all terminals)
	NOCOLORS => 0, # set to 2 in the evidencer.cfg file to totally disable colored help
);

my $SUIT = $ENV{'SUIT'} // "";
$SUIT = $1 if ( !$SUIT && getcwd() =~ m{/suits/(\w+)} );

my ( $opt_help, $opt_man, $opt_complete, $opt_version );

our %OPTIONS = (
	'h|help|?!'     => \$opt_help,
	'man!'          => \$opt_man,
	'complete!'     => \$opt_complete,
	'c|config=s'    => \$CFGFILE,
	'D|DEBUG+'      => \$BASECFG{DEBUG},
	'v|verbose'     => \$BASECFG{VERBOSE},
	'd|dryrun'      => \$BASECFG{DRYRUN},
	'U|UTC'         => \$BASECFG{UTC},
	'C|createdirs'  => \$BASECFG{CREATEDIRS},
	'k|keep'        => \$BASECFG{KEEP},
	'n|noautofix'   => \$BASECFG{NOAUTOFIX},
	'u|unfold'      => \$BASECFG{UNFOLD},
	'f|fold'        => \$BASECFG{FOLD},
	'F|force+'      => \$BASECFG{FORCE},
	'E|extra=s'     => \$BASECFG{EXTRA},
	'e|export=s@'   => \$BASECFG{EXPORT},
	'g|group'       => \$BASECFG{GROUP},
	'b|bundle'      => \$BASECFG{BUNDLE},
	'r|redefine=s@' => \$BASECFG{REDEFINE},
	's|suit=s'      => \$SUIT,
	'S|separator=s' => \$BASECFG{SEPARATOR},
	'a|argument=s@'  => \$BASECFG{ARG},
	'q|quote'       => \$BASECFG{QUOTE},
	't|test=s'      => \$BASECFG{TEST},
	'w|warnings'    => \$BASECFG{WARNINGS},
	'Q|query=s@'    => \$BASECFG{QUERY},
	'l|loop=s@'     => \$BASECFG{LOOP},
	'o|on=s@'       => \$BASECFG{ON},
	'V|version'     => \$opt_version,
	'x|xfilter'     => \$BASECFG{XFILTER},
);

# Do not override these from configuration file if set from the commandline through params
# When using redefine: -r VAR:=VALUE it automatically adds it here
our %DONOTOVERRIDE = map { $_ => 1 } qw(DEBUG VERBOSE DRYRUN CREATEDIRS FORCE);

# Try to read ./.evidencer if it exists and execute it. (use it to add parameter functions)
my $dotme = $me;
$dotme =~s{^.*/\K}{.};
do $dotme if -f $dotme;

# if COMP_CWORD is defined, then tab-expansion is active. We process the options without removing them from @ARGV
if(defined $ENV{'COMP_CWORD'} ){
	# Now we do need a change in behavior if a suit is loaded, because we have other tests
	# so we need to process the incomplete commandline, but preserve it at the same time.
	my @_ARGV = @ARGV;
	{no warnings; Getopt::Long::Configure("pass_through"); GetOptions(%OPTIONS) };
	@ARGV = @_ARGV;
}else{
	my $num_args = $#ARGV;
	# Before GetOptions, check if we have a -- and grab the arguments into %{ARG}
	if ( grep /^(?:\-\-|—)$/, @ARGV ) {
		@_ = ();
		while ( ( $_ = pop @ARGV ) !~ /^(?:\-\-|—)$/ ) {
			unshift @_, $_;
		}
		@{$BASECFG{ARG}} = @_;
	}

	GetOptions(%OPTIONS) or pod2usage(1);

	die "$me Version $VERSION\n" if $opt_version || (!@ARGV && $BASECFG{VERBOSE} && $num_args < 1);

	pod2usage( -verbose => 1 ) if defined $opt_help && !@ARGV;
	if(defined $opt_man){
		# pod2use works well on machines that have perl-doc installed. If it's not installed, 
		# it shows the whole program, not just the manual. If not installed (debian 10 does not,
		# RHEL 8.x does), the perldoc is a small stub. We detect it, and roll our own documentation.
		# Or else, it needs to be installed, for example:
		# apt-get install perl-doc
		my $exe = "/usr/bin/perldoc";
		if( -f $exe && -s $exe >125 && !$BASECFG{'FORCE'}){
			pod2usage( -verbose => 2 )
		}else{
			pod3usage( -verbose => 2 );
		}
	}

	# Make sure at least one argument provided
	if ( !$opt_complete && !@ARGV && !$BASECFG{'CREATEDIRS'} && !$BASECFG{'QUERY'} ) {
		pod2usage( -verbose => 0, -message => "$0: one argument required" );
	}
}

# Convert Arguments array to space separated string
if ( $BASECFG{'ARG'} ) {
	if ( ref $BASECFG{'ARG'} eq "ARRAY" ) {
		$BASECFG{'ARG'} = join " ", @{ $BASECFG{'ARG'} };
	}
}

# Read configuration file(s)
sub readCFG
{
	my ( $NEWCFG, $NEWSUIT ) = @_;
	$NEWCFG  = $NEWCFG  || '';
	$NEWSUIT = $NEWSUIT || '';
	my $BASEDIR = dirname $me;
	%CFG = (
		$NEWCFG && !$NEWSUIT ? %CFG : %BASECFG,
		(
			'BASEDIR'        => $BASEDIR,
			'TEMP'           => $BASEDIR . "/tmp",
			'SUITSDIR'       => $BASEDIR . "/suits",
			'SUIT'           => $NEWSUIT || $CFG{'SUIT'} || '..',
			'SERVERS'        => 'servers',
			'SCRIPTS'        => 'scripts',
			'RESULTS'        => 'results',
			'_SELECTED_SUIT' => $NEWSUIT || $CFG{'SUIT'} || '..',
			'ERRORCODE'      => 0,
			'RUN_BEGAN'      => 0,
			'CFGDIR'         => $BASECFG{'CFGDIR'} || '.',
		)
	);

	updateTime( \%CFG );    # cfgfile might need the variables.
	my ( $name, $path, $suffix ) = fileparse( $me, '.pl' );
	my $_CFGFILE = $NEWCFG
		|| (
			$NEWSUIT
			? $CFG{'SUITSDIR'} . '/' . $NEWSUIT . '/' . $name . '.cfg'
			: $path . $name . '.cfg' );
	-f $_CFGFILE
		|| -f ( $_CFGFILE = $CFG{'SUITSDIR'} .'/'. $NEWSUIT .'/'. $CFG{'CFGDIR'} .'/'. $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . $CFG{'CFGDIR'} .'/'. $name . '.cfg' )
		|| -f ( $_CFGFILE = $path . '../' . $CFG{'CFGDIR'} .'/'. $name . '.cfg' );

	if ( -f $_CFGFILE ) {
		$CFG{'CFGFILE'} = $_CFGFILE;
		say "readCFG($NEWCFG,$NEWSUIT)=$_CFGFILE" if $BASECFG{'VERBOSE'} && !$opt_help && !$opt_complete;
		open( my $CFH, '<', $_CFGFILE ) or abort("$_CFGFILE $!");
		my %DIRS = map { $_ => 1 } qw(TEMP);
		my $line;
		while (<$CFH>) {
			next if /^#/ || !/=/;
			chomp;
			s/\s+$//;
			$_.=$line while(s/\\\s*$// && chomp($line=<$CFH>));
			if (/^ALIAS\s+([^=]+)\s*=\s*(.*)\s*/s) {
				$CFG{'ALIAS'}{$1} = $2;
			}elsif(/^EXPORT\s*=\s*(.*)\s*$/){
				push @{$CFG{'EXPORT'}}, $1; # comma split later
			} else {
				my ( $k, $v ) = split /=/, $_, 2;
				$v = xexpand( $v, '%\{(\w+)\}', \%CFG ) if index( $v, "%{" ) > -1;
				$v = abs_path($v) if $DIRS{$k};
				$v=~s/\\033/\033/ if $k=~/^C:/;
				$CFG{$k} = $v unless $DONOTOVERRIDE{$k} && defined $CFG{$k};
			}
		}
		close $CFH;
	}
	for my $k (qw(SUIT)) {
		$CFG{$k} = $ENV{$k} if defined $ENV{$k};
	}
	if ( $CFG{'REDEFINE'} ) {
		&redefine();
	}
}

readCFG( $CFGFILE ); # Read toplevel evidencer.cfg only for CFGDIR
$BASECFG{'CFGDIR'} = $CFG{'CFGDIR'} if $CFG{'CFGDIR'} ne $BASECFG{'CFGDIR'};
readCFG( $CFGFILE, $SUIT ) if $SUIT;

$CFG{'DEBUG'}=0 if defined $ENV{'COMP_CWORD'} ;

# Get variables defined in the .cfg file, and print them out. (if no other arguments are given)
sub doQuery{
	my @want;
	$_=~/,/? push(@want, split(/\s*,\s*/, $_)):push(@want,$_)  for @{$BASECFG{'QUERY'}};
	my %found;
	my %found_alias;
	for my $w (@want){
		if($w=~s{^/(.*)/$}{$1}){
			map { ++$found{$_} if /$w/ } (keys %CFG);
			map { ++$found_alias{$_} if /$w/ } (keys %{$CFG{'ALIAS'}});
		}else{
			++$found{$w} if defined $CFG{$w};
			++$found_alias{$w} if defined $CFG{'ALIAS'}{$w};
		}
	}

	say $_.'='.(defined $CFG{$_}? xexpandAll($CFG{$_}) : "") for sort keys %found; # bug: /\033/\\033/g 
	say $_.'='.(defined $CFG{'ALIAS'}{$_}? xexpandAll($CFG{'ALIAS'}{$_}) : "") for sort keys %found_alias;

	&cleanup();
	exit;
}


&doQuery() if defined $BASECFG{'QUERY'} && !@ARGV;

%_CFG = UnDeepCopy( \%CFG );    # Backup real base configuration so each test can change it
say "BASEDIR=$CFG{'BASEDIR'} CFGFILE=$CFG{'CFGFILE'}" if $CFG{'DEBUG'};

# Help for the last argument given.
# Add verbose: -hv  to also show the extra help #+: in the script
# Add a + in the argument to search for the term in-between the method scripts
# use a dot to show all help from all scripts that have it
if($opt_help && @ARGV && !$opt_complete) {
	my $SUITDIR = $CFG{'SUITSDIR'}.'/'.$CFG{'SUIT'}.'/';
	# Read all fils in ./scripts/ that are methods (i.e. have the form: script=serverfilter)
	my @methods = grep { /=/ && -x "${SUITDIR}$CFG{'SCRIPTS'}/$_" } getdir(${SUITDIR}.$CFG{'SCRIPTS'});

	my %K;
	my $search = pop @ARGV; # only consider the last argument parameter given
	$search =~ s/=.*//; # remove the server part, if there

	# Deep search for a word inside any comments in the scripts, and display that method
	my $better = $search=~s/\+//;
	if($better){
		for my $k (@methods){
			++$K{$k} if readfiletoarray("${SUITDIR}$CFG{'SCRIPTS'}/$k",-1,"#.*$search");
		}
		@methods = keys %K; # show help for all methods found with the searchterm
	}else{
		%K=();
		++$K{$_} for grep { /$search/i } @methods; # search in names only
	}

	{ no warnings;
	for my $k (sort keys %K){
		my ($title) = split /=/, $k;
		my @txt = readfiletoarray("${SUITDIR}$CFG{'SCRIPTS'}/$k",-1, $BASECFG{'VERBOSE'}? "^#.\?:": "^#:");
		next unless @txt;
		grep s/<0>/$title/g, @txt;
		grep s/<\.>/basename($0)/ge, @txt;
		grep s/<(?:.|\d+)[:.]?>//g, @txt if $CFG{'NOCOLORS'};
		grep s/<([A-Z_])>(\S+)/$CFG{'C:'.$1}$2$BASECFG{'C:N'}/g, @txt; # <B>word
		grep s/<(\w*)([:.])>/ $1 ? ( $1>0 ? "\033[".($2eq':'?38:48).";5;${1}m" : "$CFG{'C:'.$1}" ) : $BASECFG{'C:N'}/gex, @txt; #<123:> ... <:>  #<123.> BGCOLOR
		grep s/<(\d+)>(\S+)/\033[38;5;${1}m$2$BASECFG{'C:N'}/g, @txt; # <123>word
		grep s/^#([\!\=]):(.*)$/"#:\n$2".($1 eq "!"?"\n":"")/e, @txt; # titles and notes
		say "\n=== " . ($CFG{'NOCOLORS'}>1? '':$BASECFG{'C:B'}) . "${title}" . ($CFG{'NOCOLORS'}>1? '':$BASECFG{'C:N'}) . " ===\n";
		say join "\n", grep { s/^#.?:// } @txt;
		say "";
	}
	}

	exit 0;
}

# Completions
#
## # if [[ "${-}" =~ 'i' ]];then  #Uncomment to not load when running non-interactively
## function _getopt_complete () {
##  COMPREPLY=($( COMP_CWORD=$COMP_CWORD perl `which ${COMP_WORDS[0]}` --complete ${COMP_WORDS[@]:0} ));
## };
## complete -F _getopt_complete evidencer
## # fi
#
if ($opt_complete)
{
	# print completion code
	unless($ENV{'COMP_CWORD'}){
		say join "\n", grep { s/## // && (!/-F/ || (@ARGV?s/\w+$/$ARGV[0]/:s/\w+$/basename($0)/e)) && !/# / } readfiletoarray($0, -1, '^##');
		exit
	};
	my $SUITDIR = $CFG{'SUITSDIR'}.'/'.$CFG{'SUIT'}.'/';

	my @candidates;
	my %K;
	my $m = $#ARGV - $ENV{'COMP_CWORD'};
	my $n = $ENV{'COMP_CWORD'} + 1;

	my $search = $ARGV[ $n ] || "";
	my $prev = $n>1? $ARGV[ $n-1 ] : "";

	# special case: complete single letter
	if( ($search =~ /^-\w/) && ($m>0)){
		say $search||" "; exit;
	}

	# If options have an argument, suggest it.
	my %PX=(
		'-c' => {'--config' => sub{
			my $cdir = $CFG{'CFGDIR'} ? $CFG{'CFGDIR'} : '.';
			my @cfgs = grep { /\.cfg$/ && -f "$cdir/$_" } getdir($cdir);
			$search=$search =~/^-/ ? '.' : $search;
			@candidates = grep { $_=$cdir.'/'.$_; /^$search/} @cfgs;
			say join " ", @candidates;
		}},
		'-s' => {'--suit' => sub{
			my @suits = grep { -d "$CFG{'SUITSDIR'}/$_" } getdir($CFG{'SUITSDIR'} );
			$search=$search eq '-s' ? '.' : $search;
			@candidates = grep {/^$search/} @suits;
			say join " ", @candidates;
		}},
	);
 
	for my $short_opt (keys %PX){
		for my $long_opt (keys %{$PX{$short_opt}}){
			if(($search eq $short_opt || $search eq $long_opt)
			|| ($prev eq $short_opt || $prev eq $long_opt) && (!$search||$m>0)){
				&{$PX{$short_opt}{$long_opt}};
				exit;
			}
		}
	}

	my $wantservers = $search =~/=/ || $prev eq '='? 1 : 0;
	my $realsearch = $search;

	# Process parameters that start with - AND need a parameter
	if ( $prev =~ m/^\-/ && (!$search || ($m > 0 && $search !~ m/^\-/ ))) {
		my %P = map {@_=split(/\W+/); $_[0]=>1,$_[1]=>1} grep{/=/} keys %OPTIONS;
		my $opt = $prev;
		$opt=~s/^-+//;
		if ($P{$opt}){
			# If needs argument, suggest something from the history (if written to)
			# append to the history file immediately with history -a (user needs to do this in the shell)
 			$prev =~ s/\-/\\-/g;
 			my $bfile = "$ENV{HOME}/.bash_history";
 			if ( -r $bfile){
				@candidates = grep {/$prev/} readfiletoarray($bfile,-1,"^\\S*".basename($0));
				@candidates = grep {s/^.*$prev\s+(\S*).*/$1/} @candidates;
				@candidates = grep { /^$search/ } @candidates;
				say join ' ', @candidates;
			}
			exit;
		}
	}

	if ( $search =~ m/^\-/ && $m >0) {
		my $dashes = 0;
		@candidates = keys %OPTIONS;
		if ( $search =~ s/^\-\-// ) {
			s/^.\|// for @candidates;
			s/[\:\=\|\!\+].*$// for @candidates;
			$dashes = 2;
		} elsif ( $search =~ s/^\-// ) {
			@_ = ();
			s/\|.*//g?push @_,$_:0 for @candidates;
			@candidates=@_;
			$dashes = 1;
			push @candidates, '-';
		}

		if($search){
			@candidates = map { $_ = '-' x $dashes . $_ } grep {/^$search/} @candidates;
		}else{
			@candidates = map { $_ = '-' x $dashes . $_ } @candidates;
		}
		say join " ", sort @candidates;
		exit 0;
	}


	# Process ALIAS that start with /
	if ( $search =~ m/^\// && $m >0) {
		say join " ", grep { /^$search/ }  (sort keys %{$CFG{'ALIAS'}});
		exit 0;
	}

	my @methods = grep { /=/ && -x "${SUITDIR}$CFG{'SCRIPTS'}/$_" } getdir(${SUITDIR}.$CFG{'SCRIPTS'});

	#my @serverfiles = grep { /=/ && -x "${SUITDIR}$CFG{'SERVERS'}/$_" } getdir(${SUITDIR}.$CFG{'SERVERS'});
	
	if(!@methods && $CFG{'WARNINGS'}){
        warn "You have no executable scripts in ${SUITDIR}$CFG{'SCRIPTS'}. Maybe you forgot chmod +x ?"
	}

	$search =~ s/[.]/\\./g; # escape dots
	if ( !$search ) {
		# If we have nothing yet, suggest methods up until the first point (if they have)
		my @M = @methods;
		++$K{$_} for grep { s/=\K.*//; s/\..*/\./ || s/=\K.*// } @M;
		@candidates = keys %K;
		unless ($#candidates == 0 && $candidates[0] =~ /[\.=]$/){
			say join " ", @candidates;
			exit ;
		}
	} elsif ( $search !~ /=/ && $ARGV[ $ENV{'COMP_CWORD'} ] ne '=' ) {
		my @M = @methods;
		if($search=~/\+/){
			for my $fragment (split /\+/, $search){
				@M = grep { /$fragment/i } @M if $fragment;
			}
			++$K{$_} for @M;
		}else{
			++$K{$_} for grep { s/^$search[^\.]*?\K\..*/\./ || /^$search/ } grep { /^$search/ } @M;
		}
		@candidates = keys %K;
	}
	if ((@ARGV && $ARGV[ $ENV{'COMP_CWORD'} ] eq '=') || $search eq '=' ) {
		$search =
			$search eq '='
			? $ARGV[ $ENV{'COMP_CWORD'} ] . '=+'
			: $ARGV[ $ENV{'COMP_CWORD'} - 1 ] . '=' . $search;
		@candidates = ( $search );
	}

	if ( $#candidates == 0 && $candidates[0] !~ /=/ ) {
		$search = $candidates[0];
		@candidates = grep { /^$search[^\.]*/ } @methods;
	}

	%K = ();
	my %T = ();

	for my $k (@candidates) {
		%CFG = UnDeepCopy( \%_CFG );
		if ( $k !~ /=/ ) {
			++$K{$k};
		} else {
			my %X = getscripts( getSuitAndScriptsAndHostStr($k), $k );
			for my $i ( keys %X ) {
				for my $j ( keys %{ $X{$i} } ) {
					my $a = $i;
					my $b = $j;
					$a =~ s/=.*//;
					$b =~ s/.*://;
					$a =~ s/.*:// unless $k =~ /:/;
					++$K{$a};
					my $c = "$a=$b";
					$c =~ s/.*=//
					  if ( $realsearch !~ /=/ && $ARGV[ $ENV{'COMP_CWORD'} ] eq '=' )
					  || $realsearch eq '=';
					++$T{$c};
				}
			}
		}
	}

	# if we have more than 1 test, only display testnames, else also with servernames
	if ( scalar keys %K > 1  && !$wantservers) {
		say join " ", sort keys %K;
	} else {
 		say join " ", sort keys %T;
	}

	exit;
}

# Create directory
sub md
{
	if ( !-d $_[0] ) {
		say "mkdir $_[0]";
		mkdir $_[0];
		return 1;
	} elsif ( $CFG{'VERBOSE'} || $CFG{'DEBUG'} ) {
		say "#Directory already exists: $_[0]";
		return 0;
	}
}

# if -C is used, we create a directory structure for a suit
if ( $CFG{'CREATEDIRS'} ) {
	$SUIT = $SUIT || $CFG{'SUIT'};
	my $c = 0;
	$c += !!md( $CFG{$_} )                                       for (qw(TEMP SUITSDIR));
	$c += !!md( $CFG{'SUITSDIR'} . '/' . $SUIT );
	$c += !!md( $CFG{'SUITSDIR'} . '/' . $SUIT . '/' . $CFG{$_} ) for (qw(SERVERS SCRIPTS RESULTS));
	say "$c directories created";

	my $sfile = $CFG{'SUITSDIR'} . '/' . $SUIT . '/' . basename($0);
	if(defined $CFG{'SUIT_LINK'} && $CFG{'SUIT_LINK'}  && $SUIT ne '..' && ! -f $sfile){
		#my $r=symlink $me, $sfile; # symlink with absolute path
		my $r=symlink '../../'.basename($0), $sfile; # relative path (looks better when ls -l)
		if($r==1){
			say "symlinked $sfile"
		}else{
			say "ERROR: Could not create symlink\n $sfile\nfor\n $me\n $!"
		}
	}
	my $cfile = $CFG{'SUITSDIR'} . '/' . $SUIT . '/' . basename($0).'.cfg';
	if(defined $CFG{'SUIT_CFG'} && $CFG{'SUIT_CFG'} && $CFG{'CFGFILE'} && -r $CFG{'CFGFILE'} && $SUIT ne '..' && ! -f $cfile){
		if(open(my $FOUT, '>', $cfile )){
			if(open(my $FIN,'<',$CFG{'CFGFILE'})){
				print $FOUT $_ while($_=<$FIN>);
				say "cfg copied $cfile";
				close $FIN;
			}
			close $FOUT;
		}else{
			say "ERROR: Could not write cfg file $cfile $!";
		}
	}
	exit 0;
}

pod2usage( -verbose => 0, -message => "$0: SUIT directory required $CFG{'SUITSDIR'}\n" )
  unless -d $CFG{'SUITSDIR'};

# if the -o option is used, create a servers/tmp.lst file and put all servers in that file; then act as normal.
if ( defined $BASECFG{'ON'} ) {
    my $tempserverfile = $CFG{'TMPFILE'}? $CFG{'TMPFILE'} : 'tmp.lst';
    my $tempserverfilefq = $CFG{'SUITSDIR'} .'/'. ($SUIT||$CFG{'SUIT'}) .'/'. $CFG{'SERVERS'} .'/'. $tempserverfile;
    say "Saving ON list to $tempserverfilefq" if $CFG{'DEBUG'};
    open(my $sfh, '>', $tempserverfilefq) or die "FATAL: $tempserverfilefq $!";
    for my $on (@{$BASECFG{'ON'}}){
        for my $svr (split /,/, $on){
            chomp $svr;
            say $sfh $svr;
        }
    }
    close $sfh;
    push @{$BASECFG{'LOOP'}}, $tempserverfile;
}


# We have done all pre-checks, we start running (unless we do a -Q query)
runit('RUN_START') unless defined $BASECFG{'QUERY'};

# Split argument string into suit, scripts and hoststr (suit:scripts=+@hoststr)
sub getSuitAndScriptsAndHostStr
{
	my ($argv) = @_;
	$argv =~ s/\\=/=/;    # remove backquote before equals, when set by Completions
	$argv =~ s/\\:/:/;    # remove backquote before colon, when set by Completions
	$argv = unalias($argv);
	$CFG{'ARGV'} = $argv;
	my ( $suit, $scripts, $hoststr ) =
		index( $argv, ':' ) > -1 ? split( ':', $argv, 2 ) : ( $SUIT || $CFG{'SUIT'}, $argv );
	( $scripts, $hoststr ) = split( '@', $scripts, 2 ) if index( $argv, '@' ) > -1;
	if ( $CFG{'_SELECTED_SUIT'} ne $suit ) {
		%CFG = &UnDeepCopy( \%BASECFG );
		readCFG( $CFGFILE, $suit );
		$scripts = unalias($scripts);
	}

	# make a proper scripts (add =* if not there, unless -o)
	$scripts .= '=' if index( $scripts, '=' ) == -1;
	$scripts =~ s/=$/=#/ if defined $BASECFG{'ON'};
	$scripts =~ s/=$/=*/;
	$scripts =~ s/^=/*=/; # It's a bad idea once you have many scripts

	# allow for ALIASes to have %{} variables, and be expanded inside $scripts
	if ( index( $scripts, "%{" ) > -1 ) {
		updateTime( \%CFG );
		my $v = xexpand( $scripts, '%\{(\w+)\}', \%CFG );
	}
	return ( $suit, $scripts, $hoststr );
}

sub getscripts
{
	my ( $suit, $scripts, $hoststr, $argv ) = @_;
	my @REG_SCRIPTS;
	my @REG_SERVERS;
	my %SCRIPT_FILES;

	# define the ./scripts/ and ./servers/ directories for this query (depends on the $suit)
	my $scriptsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
	my $serversdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SERVERS'};
	{no warnings; say "scriptsdir=($scriptsdir) suit=($suit) scripts=($scripts) hoststr=($hoststr)"
		if $CFG{'DEBUG'}; };
	$scriptsdir = abs_path($scriptsdir)
		|| pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $scriptsdir\n" );
	$serversdir = abs_path($serversdir)
		|| pod2usage( -verbose => 0, -message => "$0: SCRIPTS directory required $serversdir\n" );

	# Isolate the $reg_scripts, there might be a configuration file for it
	my ( $reg_scripts, $reg_servers ) = split /=/, $scripts, 2;

	# Read the config for the test, if it exists (merges configuration with existing).
	# Bug: when multiple inlines are run, then it does not clean up the cfg from prev.
	readCFG($_)
		if ( ( !$CFGFILE )
		&& ( -f ( $_ = "$CFG{SUITSDIR}/$suit/$reg_scripts.cfg" ) 
			|| -f ( $_ = "$CFG{SUITSDIR}/$suit/$CFG{CFGDIR}/$reg_scripts.cfg" )) );
	$CFG{'RUNSCRIPT'} = $reg_scripts; # make it available

	# If we are using +, transform it to something glob can use to find servers
	globlize($reg_scripts);
	globlize($reg_servers);

	# Give me all scripts that match the scripts name, independant of servers
	@REG_SCRIPTS = map { basename($_) } glob( $scriptsdir . '/' . "$reg_scripts=*" );
	if(! defined $ENV{'COMP_CWORD'} ){
		warn "Nothing found for SCRIPTS $scriptsdir/$scripts\n"
			unless @REG_SCRIPTS || !$CFG{'WARNINGS'};
	}

	# support for last modified scripts file. test=#
	my $last_only = 0;
	if($reg_servers eq '#'){
		$last_only=1;
	}else{
		$reg_scripts =~s/([*\[\]])/\\$1/g; # Escape asterix for glob to work
		$reg_servers =~s/([*\[\]])/\\$1/g;
		# allow for script=file1,file2 by translating to: ^script=file1$|^script=file2$
		if($opt_complete){
			$scripts = join '|', glob "{\^}{$reg_scripts}={$reg_servers}";
		}else{
			$scripts = join '|', glob "{\^}{$reg_scripts}={$reg_servers}{\$}";
		}
	}

	# Now, for the found scripts, check the servers part and match it against it's $reg_server
	my $matches = 0;
	for my $script (@REG_SCRIPTS) {
		@REG_SERVERS = ();
		my ( $reg_script, $reg_server ) = split /=/, $script, 2;
		next unless $reg_server;    # skip files that do not have servergroup candidates
		globlize($reg_server);
		say "For $script, search for servers: $reg_server in $serversdir argv:($argv)"
		  if $CFG{'DEBUG'};
		if($last_only){
			push( @REG_SERVERS, map basename($_->[0]),
			sort { $b->[1] <=> $a->[1] } map [ $_, +(stat $_)[9] ],
			grep $_ ne '.' && $_ ne '..' && -f $_, glob( $serversdir . '/' . '*' ) );
			@REG_SERVERS = ($scripts = $REG_SERVERS[0] || "");
		}else{
			push( @REG_SERVERS, map { basename($_) } glob( $serversdir . '/' . $reg_server ) );
		}
		warn "No server files found that match $CFG{'SERVERS'}/$reg_server\n"
		  unless @REG_SERVERS || !$CFG{'WARNINGS'};

		# And for that real server string representing a file, match our pattern $scripts
		for my $server (@REG_SERVERS) {
			my $scriptserver = $script;
			$scriptserver =~ s/=\K.*/$server/;
			my $scriptsreg = $scripts;
			$scriptsreg =~ s/\./\\./g;
			globlize($scriptsreg);
			$scriptsreg =~ s/([\*\?])/.$1/g;    # glob-regexp to perl-regexp
			my $is_match = $scriptserver =~ /$scriptsreg/;
			++$matches if $is_match;
			say
"check FIT argv: $argv script: $script scripts:$scripts\n scriptsreg: $scriptsreg scriptserver: $scriptserver\n"
				. " server=$server  $scriptserver =~/ $scriptsreg / matches=$matches"
				if $CFG{'DEBUG'} && $is_match;
			++$SCRIPT_FILES{ $suit . ':' . $script }{ $suit . ':' . $server } if $is_match;

			if ($hoststr) {
				# TODO: give it a pointer to where $hoststr has regexp (split /,/)
				@{ $SCRIPT_FILES{ $suit . ':' . $script }{'!'} } = split /,/, $hoststr;
			}
		}
		abort("FATAL: $scripts matches more than MAXMATCHES=$CFG{'MAXMATCHES'} (use '-r MAXMATCHES=n' to override)")
			if defined $CFG{'MAXMATCHES'} && $matches > $CFG{'MAXMATCHES'} && !defined $ENV{'COMP_CWORD'};
	}
	warn "No scripts and server files found for $scripts ($argv)\n"
		if ( @REG_SCRIPTS && !$matches && $CFG{'WARNINGS'} && !defined $ENV{'COMP_CWORD'} );
	%SCRIPT_FILES;
}

# Each argument can give us a combination test+servers, so we unite the list (to remove duplicates)
my $arg_n = 0;
while($arg_n <= $#ARGV) {

	my $argv = $ARGV[$arg_n];
	# Should the argument have come quoted and is more than one, then split and add it to the loop
	$argv = unalias($argv);
	if ( index( $argv, ' ' ) > -1 ) {
		splice @ARGV, $arg_n, 1, split / +/, $argv;
		next;
	}

	say "Processing ARG: $argv" if $CFG{'VERBOSE'};

	# Redefine commandline
	if($argv=~s/^&//){
		push @{$CFG{'REDEFINE'}}, $argv;
		&redefine();
		++$arg_n;
		next;
	}

	# Replace =# with the -l loop serverscripts (can be comma separated)
	if(defined $BASECFG{'LOOP'}){
		my $svrs = join ",", @{$BASECFG{'LOOP'}};
		if($argv=~/=/){
			grep s/=\K#?$/$svrs/e,$argv;
		}else{
			$argv.= '='.$svrs;
		}
	}

	%CFG = UnDeepCopy( \%_CFG ) if $#ARGV;    # only restore if more than one test
	my ( $suit, $scripts, $hoststr ) = getSuitAndScriptsAndHostStr($argv);
	if ( !$hoststr ) {
		if ( $CFG{'UNFOLD'} ) {
			$hoststr = '.';
		} else {
			$hoststr = "";
		}
	}
	say "Processing: suit($suit) scripts($scripts) hoststr($hoststr)" if $CFG{'VERBOSE'};

	my %SCRIPT_FILES = getscripts( $suit, $scripts, $hoststr, $argv );

	# after adding in %SCRIPT_FILES what combinations we run, we check if we have multiple scripts
	# If we do, then we separate them, because we could have separate configuration files.
	if(scalar keys %SCRIPT_FILES > 1){
		my %scriptnames;
		for my $k (keys %SCRIPT_FILES){
			$k=~s/=.*//;
			++$scriptnames{$k};
		}
		if (scalar keys %scriptnames > 1){
		say "Multiple scripts match $scripts individualizing." if $CFG{'VERBOSE'};
		my %multiscripts;
		for my $k (sort keys %SCRIPT_FILES){
			my $s_svr = $argv; $s_svr =~ s/^.*?=//;
			my $s_arg = $k; $s_arg =~ s/=.*//;
			++$multiscripts{$s_arg . '=' .$s_svr};
		}
		splice @ARGV, $arg_n, 1, sort keys %multiscripts;
		next;
		}
	}

# Now loop over all scripts and make sure they do not overlap tests. For example, say:
# You have test1=VM+ and test1=VM-ET, so the servergroup VM-ET matches both, clearly it is better to run test1=VM-ET
	if ( !$CFG{'NOAUTOFIX'} ) {
		my %TEST2SCRIPT;
		for my $suitscript ( sort keys %SCRIPT_FILES ) {
			my ( $test, $server ) = split /=/, $suitscript, 2;
			push @{ $TEST2SCRIPT{$test} }, $suitscript;
		}
		for my $test ( sort keys %TEST2SCRIPT ) {
			my %SEEN;
			for my $suitscript ( sort { length($b) <=> length($a) || $a cmp $b }
				( @{ $TEST2SCRIPT{$test} } ) ) {
				for my $servergroup ( grep { !/^!$/ } keys %{ $SCRIPT_FILES{$suitscript} } ) {
					if ( $SEEN{ $test . '=' . $servergroup }++ ) {
						$SCRIPT_FILES{$suitscript}{$servergroup} = 0;
					}

				}
			}
		}
	}
	if ( $CFG{'DEBUG'} ) {
		no warnings;
		say "DEBUG: Variables list";
		updateTime( \%CFG );
		$CFG{N} += 1;    # simulate %{N} being set somewhat correctly.
		for my $key ( sort keys %CFG ) {
			print " \%{$key}=";
			if( $_ = ref($CFG{$key}) ){
				if($_ eq "HASH"){
					print join(", ", map { "$_ -> $CFG{$key}{$_}" } keys %{$CFG{$key}});
				}elsif($_ eq "ARRAY"){
					print join ":", @{$CFG{$key}}
				}
				say "";
			}else{
				my $v = $CFG{$key};
				$v =~s/\033/\\033/g;
				say $v;
			}
		}

		for my $key1 ( sort keys %SCRIPT_FILES ) {
			for my $key2 ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$key1} } ) {
				say "DEBUG: WOULD RUN $SCRIPT_FILES{$key1}{$key2} == $key1 => $key2";
			}
		}
	}

	for my $suitscript ( sort keys %SCRIPT_FILES ) {
		my ( $suit, $script ) = split ":", $suitscript, 2;
		my $scriptsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SCRIPTS'};
		$CFG{'RUNSCRIPTSDIR'} = $scriptsdir = abs_path $scriptsdir;
		my $resultsdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'RESULTS'};
		$CFG{'RUNRESULTSDIR'} = $resultsdir = abs_path $resultsdir;
		for my $suitserver ( grep { !/^!$/ } sort keys %{ $SCRIPT_FILES{$suitscript} } ) {
			if ( $SCRIPT_FILES{$suitscript}{$suitserver} == 0 ) {
				say "SKIPPING $suitscript $suitserver ($SCRIPT_FILES{$suitscript}{$suitserver})"
				  if $CFG{'DEBUG'};
				next;
			}
			my ( $suit, $server ) = split ":", $suitserver, 2;
			my $serversdir = $CFG{'SUITSDIR'} . '/' . $suit . '/' . $CFG{'SERVERS'};
			$CFG{'RUNSERVERSDIR'} = $serversdir     = abs_path $serversdir;
			$CFG{'RUNSUIT'}       = $suit;
			$CFG{'RUNNAME'}       = $CFG{'RUNSCRIPT'} = $script;
			$CFG{'RUNNAME'} =~ s/=.*//;
			$CFG{'RUNSERVER'}   = $server;
			$CFG{'RUNSCRIPTFQ'} = $CFG{'RUNSCRIPTSDIR'} . '/' . $CFG{'RUNSCRIPT'};
			$CFG{'RUNSERVERFQ'} = $CFG{'RUNSERVERSDIR'} . '/' . $CFG{'RUNSERVER'};

			if ( $CFG{'UNFOLD'} && !defined $RICH{ $CFG{'RUNSERVERFQ'} } ) {
				if ( !defined $RICH{ $CFG{'RUNSERVERFQ'} } ) {

			# read file if we havent done so, and check if it contains nested files, or sidecomments
					readfiletoarray( $CFG{RUNSERVERFQ}, 0 );

					if ( $CFG{'UNFOLDED'} || $CFG{'RICH'} ) {
						$RICH{ $CFG{'RUNSERVERFQ'} } = 1;
					} else {
						$RICH{ $CFG{'RUNSERVERFQ'} } = 0;
					}
				}
				push @{ $SCRIPT_FILES{$suitscript}{'!'} }, '.' if $RICH{ $CFG{'RUNSERVERFQ'} };
			}

			push @{ $SCRIPT_FILES{$suitscript}{'!'} }, '.' if ($CFG{'XFILTER'} && ! defined $SCRIPT_FILES{$suitscript}{'!'});

			if ( defined $SCRIPT_FILES{$suitscript}{'!'} ) {
				say "###$script:opening $CFG{RUNSERVERFQ} for $CFG{RUNSCRIPTFQ}" if $CFG{'DEBUG'};
				my @read_servers = readfiletoarray( $CFG{'RUNSERVERFQ'}, $RICH{ $CFG{'RUNSERVERFQ'} }?1:0 );
				my @servers;
				my $counter = 0;
				my %SEEN;
				my $max = $#read_servers + 1;
				while ( ($_ = shift @read_servers) && !$SEEN{$_}++) {
					chomp;
					my $found = 0;
					++$counter;
					for my $regexp ( @{ $SCRIPT_FILES{$suitscript}{'!'} } ) {
						print "looking if $_ matches $regexp " if $CFG{'DEBUG'};
						if (
							$regexp =~ /^#(\-?\d+)(\-)?(\-?\d+)?/
							? checkrange($1,$2,$3,$counter, $max)
							: m/$regexp/ix
						) {
							s/\s+.*//;
							push @servers, $_;
							say "yes" if $CFG{'DEBUG'};
							last;
						}
						say "no" if $CFG{'DEBUG'};
					}
				}

				# Force server list unique
				@read_servers = do { my %seen; grep { !$seen{$_}++ } @servers };
				@servers = @read_servers;

				if ($CFG{'XFILTER'}){
					abort("Undefined RUN_FILTER in the configuration file") unless defined $CFG{'RUN_FILTER'};
					@read_servers = @servers;
					@servers=();
					$CFG{'RUNNAMES'} = $CFG{'RUNNAME'};
					for my $svr (@read_servers){
						$CFG{'SERVER'} = $svr;
						doQuery if defined $BASECFG{'QUERY'};
						my $DRYRUN_org = $CFG{'DRYRUN'};
						$CFG{'DRYRUN'} = 0; # let the filter always run
						my $result = runit('RUN_FILTER',1,1);
						$CFG{'DRYRUN'} = $DRYRUN_org;
						say "### RUN_FILTER: $script:filter-in '$svr':(" . ($result?'no':'yes') . ")" if $CFG{'DEBUG'};
						if($result == 0){
							push @servers, $svr;
						}
					}
				}

				{no warnings; "Filter(\@) matched "
				  . ( $#servers + 1 )
				  . " out of $counter from $CFG{RUNSERVERFQ} UNFOLDED=$CFG{'UNFOLDED'} RICH=$CFG{'RICH'} UNFOLD=$CFG{'UNFOLD'} ~> $RICH{$CFG{RUNSERVERFQ}}"
				  if $CFG{'DEBUG'}; };
				next unless @servers;    # no matches, skip this test
				     # only create a temporal file if we do not match ALL servers in this group.
				if ( $#servers + 1 < $counter || $RICH{ $CFG{'RUNSERVERFQ'} } ) {
					my $tempfile =
					    ( $suit eq ".." ? '_' : $suit ) . '#'
					  . $script . '#'
					  . $server . '#'
					  . $CFG{PID};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSERVERFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					$CFG{'RUNSERVERSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSERVER'} = $server = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSERVERFQ'} ) or abort("$CFG{RUNSERVERFQ}: $!");
					say $FOUT $_ for @servers;
					close $FOUT;
				}
			}

			# enquote
			if ( $CFG{'QUOTE'} ) {
				for my $fq (qw(RUNSCRIPTFQ RUNSERVERFQ)) {
					$CFG{$fq} =~ s/($CFG{QUOTESTR})/\\$1/g;
					$CFG{$fq} = $CFG{'QUOTESTR'} . $CFG{$fq} . $CFG{'QUOTESTR'};
				}
			}

			$CFG{'RUNNAMES'} = $CFG{'RUNNAME'} unless $DONOTOVERRIDE{'RUNNAMES'};

			if ( $CFG{'FOLD'} || $CFG{'GROUP'} || $CFG{'BUNDLE'} ) {
				say "Defering execution("
				.($CFG{'FOLD'}?'F':'f')
				.($CFG{'GROUP'}?'G':'g')
				.($CFG{'BUNDLE'}?'B':'b')
				."): $CFG{'RUNSCRIPT'} on $CFG{'RUNSERVER'}" if $CFG{'DEBUG'};
				$DEFER{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }++;
				%{$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }} = UnDeepCopy(\%CFG) unless $CFG{'GROUP'};
				%{$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{'_'}} = UnDeepCopy(\%CFG);
				push @DEFERARR, $CFG{'RUNSCRIPTFQ'}  unless (grep $_ eq $CFG{'RUNSCRIPTFQ'}, @DEFERARR);
			} else {
				&executerun();
			}
		}
	}
	++$arg_n;
}

# If running actions were defered (because of folding/grouping/bundling), run them now
if (%DEFER) {
	say "CONTINUE Defered execution" if $CFG{'DEBUG'};
	if ( $CFG{'GROUP'} ) {
		for my $script ( keys %DEFER ) {
			my $str = join $CFG{'SEPARATOR'}, sort keys %{ $DEFER{$script} };
			undef $DEFER{$script};
			$DEFER{$script}{"$str"} = 1;
		}
	}

	if ( $CFG{'FOLD'} ) {
		my %FOLD;
		for my $k ( keys %DEFER ) {
			for my $v ( keys %{ $DEFER{$k} } ) {
				$FOLD{$v}{$k} = 1;
			}
		}
		%DEFER = ();
		for my $k ( keys %FOLD ) {
			my $str = join $CFG{'SEPARATOR'}, sort keys %{ $FOLD{$k} };
			$DEFER{$str}{$k} = 1;
		}
	}

	$CFG{'RUNNAMES'} = join '+', grep { s{.\S*/}{}g; s{=\S*}{}g; s/\s+/+/g; } sort keys %DEFER unless $DONOTOVERRIDE{'RUNNAMES'};

	my %SEEN;
	for my $scripts ( $CFG{'FOLD'}? sort keys %DEFER : @DEFERARR) {
		$CFG{'RUNSCRIPTFQ'} = $scripts;
		for my $servers ( sort keys %{ $DEFER{$scripts} } ) {
			$CFG{'RUNSERVERFQ'} = $servers;

			if ( $CFG{'BUNDLE'} ) {
				if ( index( $scripts, $CFG{'SEPARATOR'} ) > -1 ) {
					my $tempfile =
					    ( $CFG{'RUNSUIT'} eq ".." ? '_' : $CFG{'RUNSUIT'} )
					  . '#BUNDLESCRIPTS#'
					  . $CFG{'N'} . '#'
					  . $CFG{'PID'};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSCRIPTFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					say "# BUNDLING SCRIPTS $scripts" if $CFG{'VERBOSE'};
					$CFG{'RUNSCRIPTSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSCRIPT'}     = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSCRIPTFQ'} ) or abort("$CFG{RUNSCRIPTFQ}: $!");
					for my $file ( split /$CFG{'SEPARATOR'}/, $scripts ) {
						say "## BUNDLING SCRIPT $file" if $CFG{'DEBUG'};
						next if $SEEN{$file."=".$servers}++;
						say $FOUT $_ for readfiletoarray($file);
					}
					close $FOUT;
				}

				if ( index( $servers, $CFG{'SEPARATOR'} ) > -1 ) {
					my $tempfile =
						( $CFG{'RUNSUIT'} eq ".." ? '_' : $CFG{'RUNSUIT'} )
						. '#BUNDLESERVERS#'
						. $CFG{'N'} . '#'
						. $CFG{'PID'};
					push @{ $CFG{'_CLEANUP'} }, ( $CFG{'RUNSERVERFQ'} = $CFG{'TEMP'} . '/' . $tempfile );
					say "# BUNDLING SERVERS $servers" if $CFG{'VERBOSE'};
					$CFG{'RUNSERVERSDIR'} = $CFG{'TEMP'};
					$CFG{'RUNSERVER'}     = $tempfile;
					open( my $FOUT, '>', $CFG{'RUNSERVERFQ'} ) or abort("$CFG{RUNSERVERFQ}: $!");
					for my $file ( split /$CFG{SEPARATOR}/, $servers ) {
						say "## BUNDLING SERVER $file" if $CFG{'DEBUG'};
						for $_ (readfiletoarray($file)){
							next if $SEEN{$scripts."=".$_}++;
							say $FOUT $_;
						}
					}
					close $FOUT;
				}
			}

			my $scriptfq = $CFG{'RUNSCRIPTFQ'};
			my $serverfq = $CFG{'RUNSERVERFQ'};
			my $script = $CFG{'RUNSCRIPTFQ'};
			my $server = $CFG{'RUNSERVERFQ'};
			$script =~ s{$CFG{'RUNSCRIPTSDIR'}/}{}g;
			$server =~ s{$CFG{'RUNSERVERSDIR'}/}{}g;
			%CFG = %{$_} if defined ($_=$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ $CFG{'RUNSERVERFQ'} }) 
				|| defined ($_=$CFGSTOR{ $CFG{'RUNSCRIPTFQ'} }{ '_' });
			$CFG{'RUNSCRIPT'} = $script;
			$CFG{'RUNSERVER'} = $server;
			$CFG{'RUNSCRIPTFQ'} = $scriptfq;
			$CFG{'RUNSERVERFQ'} = $serverfq;
			&executerun();
		}
	}
}

# Remove all temporal files, unless KEEP is set
sub cleanup{
	if ( !$CFG{'KEEP'} ) {
		for my $tmpfile ( @{ $CFG{'_CLEANUP'} } ) {
			say "removing temporal file $tmpfile" if $CFG{'VERBOSE'};
			unlink $tmpfile;
		}
	}
}

&cleanup();

runit('RUN_END') if $BASECFG{'RUN_BEGAN'};
runit('RUN_FINISH');
exit 0;

# Expand ALIAS variables in the parameters
sub unalias
{
	my ($str) = @_;
	if ( index( $str, '@' ) > -1 ) {
		my ( $expr1, $expr2 ) = split( '@', $str, 2 );
		$expr1 =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
		$str = $expr1 . '@' . $expr2;
	} else {
		$str =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
	}
	return $str;
}

# Now execute all RUN_* script in the predefined order (unless -Q was used, then we just print the variables)
sub executerun
{
	doQuery if defined $BASECFG{'QUERY'};
	if ( $CFG{'VERBOSE'} ) {
		say "# RUN($CFG{'ARGV'}) $CFG{RUNSUIT}:$CFG{RUNSCRIPT} on $CFG{RUNSERVER}"
		  . ( defined $CFG{'ARG'} ? " with argument '$CFG{ARG}'" : "" )." RUNNAME=$CFG{RUNNAME} RUNNAMES=$CFG{RUNNAMES}";
		say "# SCRIPT=$CFG{RUNSCRIPTFQ}";
		say "# SERVER=$CFG{RUNSERVERFQ}";
	}
	$CFG{'N'} = $BASECFG{'N'} += 1;    # Unique counter %{N} (combine with %{PID} to create tempfiles)
	my $EC;
	my $REDO = defined $CFG{'REDO'} ? $CFG{'REDO'} : 0;
	&export() if defined $CFG{'EXPORT'};
	for my $run ( glob "RUN{_PRE,,_POST}{_TEST,}" ) {
		next if $run =~ /_TEST$/ && !defined $CFG{'TEST'};
	  REDO:
		if ( defined $CFG{'ARG'} && defined $CFG{ $run . "_ARG" } ) {
			$EC = runit( $run . "_ARG", $run ne "RUN_PRE" );    # update time only for RUN_PRE
		} else {
			$EC = runit( $run, $run ne "RUN_PRE" );             # update time only for RUN_PRE
		}
		if ( $EC && $REDO > 0 && $run eq "RUN" ) {
			--$REDO;
			goto REDO;
		}
		last if ( $EC && $run =~ /_TEST|RUN_PRE/ );
	}
}

# allow executing ABORTMSG before die (usually from lacking permissions to read/write files)
sub abort
{
	$CFG{'ABORTMSG'} = $_[0];
	runit('RUN_ABORT');
	die $_[0] . "\n";
}

# Run (or dryrun) the commands defined as RUN... in the cfg file
sub runit
{
	my ( $KEY, $no_time_update, $not_started_yet ) = @_;
	if ( $_ = $CFG{$KEY} ) {
		updateTime( \%CFG ) unless $no_time_update;
		$_ = xexpandAll($_, $CFG{'DRYRUN'});

		if ( $CFG{'DRYRUN'} ) {
			say "# RUN_BEGIN:\n" . $CFG{'RUN_BEGIN'}
			  if ( defined $CFG{'RUN_BEGIN'} && !$BASECFG{'RUN_BEGAN'}++ );
			say "# $KEY:\n" . $_;
		} else {
			if ( !$not_started_yet && $KEY ne 'RUN_START' && defined $CFG{'RUN_BEGIN'} && !$BASECFG{'RUN_BEGAN'}++ ) {
				my $__ = $_;
				$CFG{'_'}=$CFG{'RUN_BEGIN'};
				$CFG{'__FAIL'}=$CFG{'RUN_BEGIN_FAIL'} if defined $CFG{'RUN_BEGIN_FAIL'};
				runit('_',1);
				delete @CFG{qw(_ __FAIL)};
				$_ = $__;
			}
			say $_ if $CFG{'VERBOSE'};
			my $ec = system $_;
			say " #($KEY) ExitCode=$?" if $CFG{'VERBOSE'};
			if ( !$not_started_yet ){
				$CFG{'TOTALERRORS'} = $BASECFG{'TOTALERRORS'} += 1 if $CFG{'ERRORCODE'} = $ec >> 8;
				runit( $KEY . "_FAIL", 1 ) if ( $ec && $KEY !~ /_FAIL$/ && $CFG{ $KEY . "_FAIL" } );
			}
			return $ec;
		}
	}
	return $CFG{'ERRORCODE'} = 0;
}

# transform lazy search into a glob-able pattern
sub globlize
{
	$_[0] =~ s/^(\+\+)|(=\K\+\+)|(\+\+)$/$1||$2?"*-":"-*"/ge; # border ++ to *
	$_[0] =~ s/\+\+|\-\-/-*-/g;                               # middel ++ to -*-
	$_[0] =~ s/\+/\*/g;                                       # all other + to *
	$_[0] =~ s/^\-/\*-/g;                                     # if starts with -, then *-
	$_[0] =~ s/\-$/-\*/g;                                     # if ends with -, then  -*
}

# xexpands %{} or ${} variables
sub xexpand
{
	my $m="";
	my $max=5;
	while(--$max && $_[0] ne $m){
		$m = $_[0];
		if($_[3]){
			$_[0] =~ s/$_[1]/defined($_[2]{$1})?$_[2]{$1}:"\${$1}"/ge;
		}else{
			$_[0] =~ s/$_[1]/defined($_[2]{$1})?$_[2]{$1}:"%{$1}"/ge;
		}
	}
	$_[0];
}

# Expand everything for a string. If -d is used, then do not expand ${} just yet, as the values might be undefined.
sub xexpandAll
{
	my($v,$isdryrun) = @_;
	if(index( $v, "%{" ) > -1){
		xexpand( $v, '%\{(\w+)\}', \%{ $CFG{'ALIAS'} } ) ;
		xexpand( $v, '%\{([\w:]+)\}', \%CFG );
	}
	if(index( $v, "\${" ) > -1 && !$isdryrun){
		xexpand( $v, '\$\{(\w+)\}', \%{ $CFG{'ALIAS'} }, '$' ) ;
		xexpand( $v, '\$\{(\w+)\}', \%CFG, '$' )
	}
	$v;
}

# Time variables exposed to CFGFILE
sub updateTime
{
	my ( $v, $e ) = @_;
	$v->{"EPOCH"} = $e = ( $e || time );
	my @T = $CFG{'UTC'} ? gmtime($e) : localtime($e);    # S M H d m+1 y+1900 wd yd daylightsaving
	$v->{"HH"} = $T[2] < 10 ? '0' . $T[2] : $T[2];     # hour (00..23)
	$v->{"MM"} = $T[1] < 10 ? '0' . $T[1] : $T[1];     # minute (00..59)
	$v->{"SS"} = $T[0] < 10 ? '0' . $T[0] : $T[0];     # seconds (00..23)
	$v->{"WD"} = $T[6] || 7;                           # 1=Monday ... 6=Saturday, 7=Sunday
	$v->{"WN"} = sprintf("%02d", int($T[7]/7)+1);      # Week number 01..52/53
	$v->{"YD"} = sprintf( "%03d", $T[7] + 1 )
	  ;    # day of the year, in the range 001..365 (or 001..366 if leap year)
	$v->{"DAY"}   = $T[3] < 10   ? '0' . $T[3] : $T[3];    # day of the month
	$v->{"MONTH"} = ++$T[4] < 10 ? '0' . $T[4] : $T[4];    # 01=jan ... 12=dec
	$v->{"YEAR"} = $T[5] + 1900;                           # 4 digits year
	$v->{"DS"}   = $T[8];                                  # daylightsaving

	$v->{"TOTALTIME"} = time - $^T;                        # total seconds running
}

# Read a file into an array, with optional filtering
# use $_recursed=-1 to read verbatim
sub readfiletoarray
{
	my ( $_file, $_recursed, $_filter ) = @_;
	{no warnings; say "readfiletoarray($_file,$_recursed,$_filter)" if $CFG{'DEBUG'}; };
	$CFG{'UNFOLDED'} = $CFG{'RICH'} = 0 unless $_recursed;
	open( my $FIN, '<', $_file ) or abort("$_file: $!");
	my @_SVRS;
	while (<$FIN>) {
        next if defined $_filter && ! /$_filter/;
		chomp;
		if (defined($_recursed) && $_recursed>-1 && /\//) {
			$CFG{'UNFOLDED'}++;    # signal that we unfolded
			s{^\.}{%{SUITSDIR}/%{SUIT}/%{SERVERS}};
			$_ = xexpand( $_, '%\{(\w+)\}', \%CFG ) if index( $_, "%{" ) > -1;
			push @_SVRS, readfiletoarray( $_, 1 , $_filter||undef);
		} else {
			$CFG{'RICH'}++ if /\s/;    # signal we have a commented hostfile
			push @_SVRS, $_;
		}
	}
	close($FIN);
	@_SVRS;
}

# 1 level deeper hash copy
sub UnDeepCopy
{
	my %COPY;
	my $ORG = $_[0];
	my $typeof;
	for my $k ( keys %$ORG ) {
		$typeof = ref( $$ORG{$k} );
		if ( !$typeof ) {
			$COPY{$k} = $$ORG{$k};
		} elsif ( $typeof eq 'ARRAY' ) {
			@{ $COPY{$k} } = @{ $$ORG{$k} };
		} elsif ( $typeof eq 'HASH' ) {
			%{ $COPY{$k} } = %{ $$ORG{$k} };
		}
	}

	%COPY;
}

# Get a directory listing as an array
sub getdir
{
    if (! -d $_[0] && $CFG{'WARNINGS'}){
    warn "\n\nYou need to create a directory structure first. Run the following to do that:\n";
    $SUIT = $SUIT || '..';
    warn "$me -Cs $SUIT\n\n";
    exit 1;
    }
	opendir( my $dh, $_[0] ) || die "Can't opendir $_[0] $!";
	my @list = grep {! /^\./} readdir($dh);
	closedir $dh;
	@list;
}

# Process all -r redefine statements.
sub redefine
{
	my $n=-1;
	for my $redef ( @{ $CFG{'REDEFINE'} } ) {
		++$n;
		next unless defined $redef;
		$redef=~s/^\s+|\s+$//g; # trim
		next unless $redef;
		my $_redef = $redef;
		if ( index( $redef, '=' ) == -1 ) {
			# for: ./evidencer -r NORUN,NOPRE
			if ( index( $redef, "," ) > -1 ) {
				push @{ $CFG{'REDEFINE'} }, split /,/, $redef;
				$CFG{'REDEFINE'}->[$n]=undef;
				next;
			}
			# if no = to assign, then it must be an alias, substitute it.
			$_redef =~ s/(?:^|\b)$_(?:\b|$)/$CFG{'ALIAS'}{$_}/g for keys %{ $CFG{'ALIAS'} };
		}
		# different commands are split by {,}
		if ( index( $_redef, "{,}" ) > -1 ) {
			push @{ $CFG{'REDEFINE'} }, split /\s*{,}\s*/, $_redef;
			$CFG{'REDEFINE'}->[$n]=undef;
			next;
		}
		# now they are in the form: variable=value, split and assign to %CFG
		$_redef =~ s/^&//; # to allow for argument and parameter aliases to work
		@_ = split /=/, $_redef, 2;
		say "# redef=($redef)" if $CFG{'DEBUG'};
		if ( defined $_[1] && index( $_[1], "%{" ) > -1 ) {
			xexpand( $_[1], '%\{(\w+)\}', \%CFG );
		}
		if($_[0]=~s/:$//){
			++$DONOTOVERRIDE{ $_[0] };
			# $BASECFG{ $_[0] } = $_[1]; 
		}
		$_CFG{ $_[0] } = $CFG{ $_[0] } = $_[1];
	}
}

sub export{
	my $n=-1;
	for my $var ( @{ $CFG{'EXPORT'} } ) {
		++$n;
		next unless defined $var;
		$var=~s/^\s+|\s+$//g; # trim
		next unless $var;
		# for: ./evidencer -e RUNSCRIPT,RUNSCRIPTFQ
		if ( index( $var, "," ) > -1 ) {
			my $_var = $var;
			@_ = split /\s*,\s*/, $_var;
			$var = shift @_;
			push @{ $CFG{'EXPORT'} }, @_;
		}
		if($var=~m{^/(.+)/$}){
			my $_var = $1;
			for my $k (grep {/$_var/ } keys %CFG){
				$ENV{$k} = $CFG{$k} || '';
			}
		}else{
			$ENV{$var} = $CFG{$var} || '';
		}
	}
}

# Helper function when a range is given, for example: TEST=SERVERLIST@#1-4 (first 4 entries in SERVERLIST)
# Negative numbers start at the end
sub checkrange
{
	my(($start,$range,$end,$counter,$max)) = @_;
	if(defined $range){
		if (defined $end){
			abort("Invalid range given:#\@ $start - $end . $end should be a negative index too") if($start<0 && $end>0);
			$start = $max+1 + $start if $start < 0;
			$end = $max+1 + $end if $end < 0;
			abort("Invalid range given:#\@ $start - $end . $end should bigger than $start") if($start>$end);
			return $start <= $counter && $counter <= $end;
		}else{
			return $start > 0 ? $counter >= $start : $max +1 -$start >= $counter;
		}
	}else{
		return $start > 0 ? $counter == $start : $max +1 -$start == $counter;
	}
}

# Attempt at making our own pod. This is required when the perl-doc package is not installed.
sub pod3usage{
	no warnings;
		my $exe;
		$exe="$_" if(($_="/usr/bin/more") && -x $_);
		$exe="$_ -R" if(($_="/usr/bin/less") && -x $_);
		#$exe="$_ -l -" if(($_="/usr/bin/man") && -x $_);

		# ./evidencer --man -r NOCOLORS=2
		if($BASECFG{'REDEFINE'}[0]=~/NOCOLORS/){
			$BASECFG{$_}="" for grep {/C:/} keys %BASECFG;
		}
		open(my $HOUT,"|$exe");
		my $skip=1;
		while(<DATA>){
			chomp;
			next if $skip && !$_ && $skip--;
			if( s/=head\d (.*)/$BASECFG{'C:B'}$BASECFG{'C:U'}$1$BASECFG{'C:N'}/){
				say $HOUT $_."\n";
				++$skip;
				next;
			}else{
				s/^=(?:item|over \d+|cut|back)// && ++$skip;
				s/L<(?:.*\|)?([^>]*)>/$BASECFG{'C:Y'}$1$BASECFG{'C:N'}/g;
				s/^((?:\$ .*|\.\/.*|eval .*))/$BASECFG{'C:L'}$1$BASECFG{'C:N'}/;
				s/`(.*?)`/$BASECFG{'C:L'}$1$BASECFG{'C:N'}/g;
				s/^(#.*)/$BASECFG{'C:A'}$1$BASECFG{'C:N'}/;
				s/B<([^>]*)>/$BASECFG{'C:B'}$1$BASECFG{'C:N'}/g;
				if(/^\S/){
					s/^/    /;
					s/(?:.{70,79}\S|\S{70,}+)\K\s+/\n    /g;
				};
				say $HOUT $_;
			}
		}
		close $HOUT;
		exit;
}
__END__

=head1 NAME

evidencer.pl - A program to combine scripts and servers to run scripts on servers.

For the full help, see README.md or directly on L<github|https://github.com/FBnil/evidencer>

=head1 DESCRIPTION

 evidencer [-s <suit>] [suit:][script]=[servergroup][@<hostnames_regexp,...|#n|#n-m>] [--help]
 
 Example:

 # Run, from the suit JAVATRANSACTIONS the test JAVASERVER-SERVICES= for servers JAVA-ET
 # that match the perl regexp javaserver00[1..5] or the substring javaserver0100
 ./evidencer JAVATRANSACTIONS:JAVASERVER-SERVICES=JAVA-ET@javaserver00[1..5],javaserver0100
 
 # Run from the 5th on the JAVA-ET@ list to the second last. (use 5--1 or 5- for 5th to last)
 ./evidencer JAVATRANSACTIONS:JAVASERVER-SERVICES=JAVA-ET@#5--2

 # show (dryrun) what would run from the suit JAVATRANSACTIONS the test
 # JAVASERVER-SERVICES= for any matching servers AND the test JAVASERVER-PORTS for any of it's
 # matching servers
 ./evidencer -s JAVATRANSACTIONS JAVASERVER-SERVICES=* JAVASERVER-PORTS -d

 JAVASERVER-SERVICES=* can be written as:
   JAVASERVER-SERVICES=  or as  JAVASERVER-SERVICES=+  or even as  JAVASERVER-SERVICES

 The servergroup part of a script name, uses a plus sign instead of an asterix, and these are the transformation rules:
 +     ==>  *       ++    ==>  *-*     +-+-+ ==>  *-*-*
 +A    ==>  *A      A+    ==>  A*      ++B   ==>  *-B
 +-A   ==>  *-A     A-+   ==>  A-*     A++   ==>  A-*
 A++B  ==>  A-*-B   A-+B  ==>  A-*B    A+-B  ==>  A*-B

 So if you have a servergroup called APACHE-PROD-DMZ, then =++DMZ would match that group.
 And ++PROD++  would match *-PROD-*. These are glob expansions, which means it would match
 exactly what ls would match if you run:  ls ./servers/*-PROD-*

 If unsure, escape or quote your servergroup and use dryrun.

 @hostnames regexp's are not un-ALIAS-ed.

 If your servers are IP adresses, you can also use descriptions, like so:

 10.2.0.1 frontend server 1
 10.2.0.2 frontend server 2
 10.2.0.3 backend server 1
 10.2.0.4 backend server 2

 Then you can select the frontend server like so:

$ ./evidencer OS.yum.update=MYSERVERS@frontend

 The filtering will remove everything after the first space and only keep the first item.
 For more complex regexp's, use quotes (to prevent the shell interpreting them), like so:

$ ./evidencer OS.yum.update=MYSERVERS@'(back|front).*1'  -Dvd

 This would match 10.2.0.1 (frontend server 1) and 10.2.0.3 (backend server 1). Case insensitive.
 Use `-Dvd` to see the matches, but not execute the statements (Debug, verbose, dryrun)

 You must have a configuration file that tells evidencer what to do with the script and the servergroup. So it at least needs a RUN= statement in that configuration file.


=head1 DIRECTORIES

 ./servers/  Define a list of server by function.

 ./scripts/  Define a list of tests, by function, to be run on those servers

 ./results/  Just an empty directory to store results in (from an external program)

 ./suits/    Once you are done with your tests, move them away into a suit, still available

 ./tmp/      A temporal directory to hold sub lists of servergroups when using hostnames_regexp

Note: You can edit evidencer.cfg beforehand to redefine these directory names. See section CONFIGURATION


to create the top-level directories use the following command: 

./evidencer -s .. -C

To create a suits directory structure:

./evidencer -C -s MYAPPL

If you have B<SUIT_LINK=1> and/or B<SUIT_CFG=1> in your configuration file, then evidencer will be symlinked into that directory and/or the evidencer.cfg file will be copied into the new suit.



=head1 CONFIGURATION

Evidencer needs a configuration file to work.

There are 3 level of configuration files: the toplevel, evidencer.cfg, then inside a suit, also
named evidencer.cfg, and then per script, the name of the script up to the = and then .cfg (permissions non executable)

Note that the lowest level is always merged with the configuration above; this way you can only configure the differences.

Note: If you rename evidencer to something more to your liking, you need to rename the evidencer.cfg too.

Variables can be used inside other variables. If written as %{VAR} then the substitution is done early,
if written as ${VAR} then the evaluation is done at runtime.

The variables that can be used are:

=over 10

=item B<BASEDIR>

The directory where the evidencer binary is located

=item B<CFGDIR>

Configuration directory Defaults to cfg. Can only be defined in the toplevel configuration file (not inside suits). Can place your cfg files in a subdirectory of the SUIT, if you prefer that.

      
=item B<TEMP>

The directory where temporal files are created. Temporal files are needed when you use @hostnames_regexp, because we need a subset of servers from the content of the servergroup file. The default is a ./temp/ subdirectory where the evidencer script is located.

=item B<SUITSDIR>

The directory where the suit directories are in. The default is a ./suits/ subdirectory where the evidencer script is located.

=item B<SUIT>

Defaults to .. this way, you do not need to worry about having a suit directory, you'll have ./servers/ and ./scripts/here in the same directory evidencer resides

=item B<SERVERS>

If for some reason, you want the ./servers/ directory name to be different, you can override this name. The default is B<SERVERS=servers>

=item B<SCRIPTS>

If for some reason, you want the ./scripts/ directory name to be different, you can override this name. For example, to use ssh-batch. That program uses inline as the directory name. The default is B<SCRIPTS=scripts>
I'd recommend using inlines to have each start with an unique letter, and making it easier to change directories.

=item B<RESULTS>

Just a directory where the results are to be kept. The default is B<RESULTS=results>

=item B<ALIAS>

You can define multiple aliases. The suit and the script in the commandline parameters are un-aliased, the hostnames_regexp is not. Example: B<ALIAS> B<ES=ELASTICSEARCH>

Alias can also be used as a parameter, but only from the point you define them in the commandline, unless you use -r, in that case it is processed before anything else.

=item B<TMPFILE>

If you use --on to loop over machinenames, a file, ./servers/tmp.lst will be created for you, with the content of the hostnames in the commandlines. You can change 'tmp.lst' by defining TMPFILE


=back


=head1 RUN variables

All variables that have to do with running found combinations of servers and scripts


=over 13

=item B<PID>

The process ID of the currently running evidencer use it as: %{PID}. Combine with %{N} for unique filenames

=item B<ARGV>

The script+server combination we are running

=item B<ARG>

Contains the string with the argument(s) passed with -- or a single argument passed with -a

=item B<N>

A number that increases just before you use the: RUN_PRE, RUN and RUN_POST. Use it like: %{N}.
If not using FOLD nor GROUP it's the number of scripts ran so far.

=item B<RUNSCRIPTSDIR>

The directory where the scripts are located, basically: %{SUITSDIR}/%{SUIT}/%{SCRIPTS}

=item B<RUNSERVERSDIR>

The directory where the servergroups are located, basically: %{SUITSDIR}/%{SUIT}/%{SERVERS}

=item B<RUNSUIT>

The currently running suit

=item B<RUNSCRIPT>

The name of the scripts file being processed

=item B<RUNSERVER>

The name of the servers file being processed

=item B<RUNSCRIPTFQ>

Fully Qualified name for the scripts file, basically: %{RUNSCRIPTSDIR}/%{RUNSCRIPT}

=item B<RUNSERVERFQ>

Fully Qualified name for the servers file, basically: %{RUNSERVERSDIR}/%{RUNSERVER}

=item B<RUNNAME>

The name of the scripts file being processed %{RUNSCRIPT}, but stripped of the = and everything to the right

=item B<RUNNAMES>

If you --bundle or --fold you might want to use the + concated scripts names, instead of RUNNAME which will contain only the last one

=item B<TEST>

Argument string given with --test on the commandline (available as %{TEST}). It can be used in your RUN_PRE_TEST or RUN_TEST (and RUN_POST_TEST), which only activate when --test is used. If it does not exit with exitcode 0, then running the rest is skipped.

=item B<RUN_PRE_TEST>

Execute this string in the shell to test the validity of the script+server combination. As with all *_TEST, Exit nonzero to skip execution of RUN_PRE and all after

=item B<RUN_PRE>

Execute this string in the shell. Runs before RUN. Time date strings are set before RUN_PRE and are the same for RUN and RUN_POST even if they take time to execute. Exit nonzero to skip.

=item B<RUN_TEST>

Execute this string in the shell to test the validity of the script+server combination. Exit nonzero to skip RUN (but RUN_PRE already ran if it was defined)

=item B<RUN>

Execute this string in the shell

=item B<RUN_POST_TEST>

Execute this string in the shell. Runs before RUN_POST

=item B<RUN_POST>

Execute this string in the shell. Runs after RUN

=item B<KEEP>

Set to true(1) to keep temporal files created when @hostnames is used

=item B<RUN_START>

This always runs at the beginning

=item B<RUN_BEGIN>

Run just before the first RUN_PRE is ran. If no scripts+servers is matched, then this does not trigger

=item B<RUN_END>

Runs at the very end of each evidencer script, only if RUN_BEGIN ran (%{RUN_BEGAN} is nonzero)

=item B<RUN_FINISH>

This always runs at the end. It has access to a number %{N} if it is zero, nothing actually ran

=item B<ABORTMSG>

The fatal errormessage will be available to RUN_ABORT to do something with it (for example:log it)

=item B<RUN_ABORT>

Execute this string in the shell when a fatal error occurred: When evidencer could not read or create a file it needs to run

=item B<MAXMATCHES>

When you run a script without a servergroup, and you can potentially run it on hunderds of serverfiles, prevent it by setting a maximum. You can redefine it in the commandline with: `-r MAXMATCHES=5`

=back

All RUN* commands have a *_FAIL counterpart. If the exitcode of the command is nonzero, then the *_FAIL will be run. The RUN_PRE is a special case: when RUN_PRE returns with a nonzero exitcode, then RUN_PRE_FAIL will also run, but then the rest, like RUN and RUN_POST will be skipped. To override this, end your RUN_PRE command with ;true.

If you use arguments (either by adding a single argument with -a or using -- at the end of the parameters, and adding your parameter(s) after it; then, if you have defined: RUN_PRE_TEST_ARG, RUN_PRE_ARG, RUN_TEST_ARG, RUN_ARG, RUN_POST_TEST_ARG, RUN_POST_ARG Then those commands will be used instead. In both cases, %{ARG} will be available to be used.

So the order is: RUN_START, RUN_BEGIN, RUN_PRE_TEST, RUN_PRE, RUN_TEST, RUN, RUN_POST_TEST, RUN_POST, RUN_END, ...(next test)... RUN_FINISH. and a *_FAIL for each of these and a RUN_ABORT when file IO fails.

The inner loop uses this glob:  echo RUN{_PRE,,_POST}{_TEST,}

=head1 OPTIONS

 [OPT         DESCRIPTION]

 -h | --help | -?   Print Options and Usage.
 --man              Print complete man page.
 -v | --verbose     Log more to the screen. Sets VERBOSE=1
 -D | --DEBUG       Log a bit more to the screen. Sets DEBUG=1
 -d | --dryrun      Do not execute, but show all that would have been run. Sets DRYRUN=1
 -U | --UTC         timestrings are in UTC instead of localtime. Sets UTC=1
 -C | --createdirs  Create directories if they do not exist
 -c | --config <cfg> Read alternative cfg file
 -k | --keep        Do not cleanup temporal files created to accomodate the @hostnames list
 -n | --noautofix   Do not skip running tests on servergroups that match multiple tests. Sets NOAUTOFIX=1
 -u | --unfold      If you have files in your servergroups, recursively read the servers. Sets UNFOLD=1
 -f | --fold        Group by Scripts. Sets FOLD=1
 -g | --group       Group by Servergroups. Sets GROUP=1
 -b | --bundle      Concatenate all scripts/servers if they are folded or grouped, into a new file. Sets BUNDLE=1
 -r | --redefine  $ Override a variable from evidencer.cfg (can be used multiple times)
 -a | --argument  $ Quick redefine that sets %{ARG} for use in RUN*_ARG scripts (if defined). Also: --
 -q | --quote       Quote your scripts and servers using %{QUOTESTR}. Handy for fold and group.
 -S | --separator $ The separation characters between folded and grouped items. (default is double space). Sets SEPARATOR
 -t | --test  <$>   Final test against a RUN (either before or after RUN_PRE) to validate the combination
 -s | --suit <suit> Only consider this suit for all script-server matches
 -w | --warnings    Enable warnings when your script=server combination does not match anything. Sets WARNINGS=1
                    Set WARNINGS=1 in the configuration file to enable it by default
 -o | --on <host>   Comma separated list of hosts (will create a serverfile for you) for =#
 -l | --loop <$>    Loop on comma separated list of serverfiles for =#
 -Q | --query <var> Prints the value of a variable defined in your evidencer.cfg and exits
 -V | --version     Prints the real file location and version and exits
 -x | --xfilter     eXcludeFilter: Filter the servers through RUN_FILTER= to determine if it needs to added in the run, before RUN_PRE.
 -e | --export <$>  Name of the variables to export to processes using the `RUN*` executes. Comma separated. Sets EXPORT=
 -E | --extra       USR Modifier (string). Use inside your .cfg as: "${EXTRA}"
 -F | --force       USR Modifier (boolean). Use inside your .cfg as: ${FORCE}. Pre set FORCE=0 in cfg

Options can be anywhere in the commandline (but not after the `--` parameter). Options can be shortened (1st letter) and can be bundled. Many options can also be set in the evidencer.cfg file.

=head1 Query

Query allows you to query any variable defined in the evidencer.cfg (or any cfg if you preload it with B<-c>)
You can also query ALIASes. Like many of the variables that accept multiple parameters, you can comma separate or issue multiple queries:

$ ./evidencer -Q TIME -r 'TIME="%{YEAR}-%{MONTH}-%{DAY} %{HH}:%{MM} %{WD}/7 %{YD}/365 %{WN}/52"'

TIME="2021-07-17 23:56 6/7 198/365 29/52"

to see all time related variables, run:  grep -F '$v->{' ./evidencer


$ ./evidencer -Q SCRIPTS,/q -Q NOW

NOW=${YEAR}-${MONTH}-${DAY}_${HH}:${MM}:${SS}

SCRIPTS=scripts

/q=&SILENCE=--quiet


Additionally, if you add a test, it will fill in the variables:

$ ./evidencer -s DEMO -Q RUN
RUN=/home/FBnil/evidencer/bin/ssh-batch ${SILENCE} --no-info --bg-log-dir "%{RUNRESULTSDIR}/${RUNNAMES}" %{RUNSERVERFQ} -- %{RUNSCRIPTFQ} > "%{RUNRESULTSDIR}/${RUNNAMES}-2021-07-23_1143.log"

$ ./evidencer -s DEMO os.show.mem=# -Q RUN
RUN=/home/FBnil/evidencer/bin/ssh-batch ${SILENCE} --no-info --bg-log-dir "/home/FBnil/evidencer/suits/DEMO/results/${RUNNAMES}" /home/FBnil/evidencer/suits/DEMO/servers/localhost -- /home/FBnil/evidencer/suits/DEMO/scripts/os.show.mem=+ > "/home/FBnil/evidencer/suits/DEMO/results/${RUNNAMES}-2021-07-23_1142.log"

=head1 EXPORT

You can keep your RUN*= configuration clean by, instead of running bash code directly, you isolate it into a script;
and pass the variables required through the `EXPORT` variable, like so:

EXPORT=BASEDIR,SILENCE,OUTPUTDIR,RUNSERVERFQ,RUNSCRIPTFQ,OUTPUTLOG

RUN=%{RUNSCRIPTSDIR}/run.sh

This means that run.sh can now use $OUTPUTDIR directly, without having to pass as a commandline parameter.

You can also use a regexp:  EXPORT=/RUN/ will export all variables that contain "RUN" in their name.

From the commandline it looks like this:

./evidencer script=serversfile -e /RUN/,BASEDIR

Note that -e always ADDs to the existing EXPORT defined in the cfg. To replace it use -r EXPORT=BASEDIR,/RUN/

TIP: While debugging you can export all variables if you use -e /./

TIP: You can use EXPORT= or -e multiple times. Note that use of -e deletes all EXPORT= defined in the cfg.


=head1 REDEFINE

You can redefine variables. If they are defined with a := then they become unmutable and won't be overriden internally.

Example:

Say you have the following scripts: os.show.boottime os.show.cpu os.show.free os.show.uptime
Then running ./evidencer os.show.+=localhost will have the RUNNAMES of:

$ ./evidencer os.show.*=localhost  -Q RUNNAMES -f
RUNNAMES=os.show.boottime+os.show.cpu+os.show.free+os.show.uptime

And that would be a weird destination directory, but if you redefine it like this:

$ ./evidencer os.show.*=localhost  -Q RUNNAMES -f -r RUNNAMES:=all_OS
RUNNAMES=all_OS

Then because of the RUN= ... --bg-log-dir "/home/nilton/CODE/PERL/evidencer/results/${RUNNAMES}" ...
The results directory name is more comprehensible.

Another trick is if you already fetched the information, and your RUN_POST shows you that information, then you can skip the RUN_PRE and RUN to only display the results you already have:

$ ./evidencer os.show.cpu=localhost -r RUN= -r RUN_PRE=

Which action you can ALIAS in your evidencer.cfg configuration file:

# Undefine all actions except RUN_POST and RUN_END. This way, you can re-display the results  without fetching the data.

# Use it like: ./evidencer /show test=serverlist   (note that the parameter order is important here)

# or like: ./evidencer test=serverlist -r /show    (order is not important, -r is always first)

ALIAS /show=&RUN:={,}&RUN_ARG:={,}&RUN_PRE:={,}&RUN_START:={,}&RUN_FINISH:={,}

Note: For this to work, your post action should be configured to display something.

=head1 Unfold

ssh-batch allows for serversfiles that contain serversfiles. For example, you have 2 files: WINDOWS and LINUX, then you create a file ALL with the following content:

./WINDOWS

./LINUX

If you rather have this unfolded in evidencer than by ssh-batch (or rundeer, which does not support it), use -u

=head1 SCRIPTS HELP

The scripts can have lines that start with #: (viewable with -h) or #+: (viewable with -hv)
For example:
./evidencer spoon -hv

If you are making your own help text inside scripts, then you can add colors with <C>, 
where C is a character, or a number. The available characters are viewable with:
B<grep C: evidencer |grep 033 |grep =>

You can span using a colon:   <B:> ... <:> 

You can set background colors with dot:  <1.> .. <:>

If you do not want colors, use NOCOLORS, like so:

./evidencer . -hv -r NOCOLORS=2

You can put this variable also in your evidencer.cfg file:

# NOCOLORS=     # default. Display help with colors

# NOCOLORS=1    # Only headers are bold, the rest is monochromatic

# NOCOLORS=2    # fully monochromatic, useful for storing in a text file.

If you start your help with: #=:  It means it starts a new paragraph (adds a newline above).
If you start your help with: #!:  It means the line is separated by a newline above and below.
Note that <0> is not a color but the name of the script for which the help is being shown (and <.> is the evidencer executable name)

#+: <Y>Example: <L:> ./<.> <0>=# <:>

Note: Scripts pushed by ssh-batch have a few constructs that can not be used (as they have to be converted to single line, hence they are also called inline scripts). See ssh-batch documentation for which. Don't worry, In practice, most work.

=head1 TAB EXPANSION

You can activate tab expansion for evidencer by putting the following in your ~/.bashrc:

./evidencer --complete >> ~/.bashrc

(and when you do that for the first time, source your bashrc first, or open a new terminal)

If you do not want to change your .bashrc, then run this to get tab expansion in your current terminal:

eval $(./evidencer --complete)

Sometimes expansion does not work, check that there is no other expansion for the binary defined:

`complete |grep evidencer` and delete it with `complete -r evidencer` then try again.


Tip: the newest file in ./servers/ is aliased to #, so to run a script on all the server in that latest file:

./evidencer os.show.boottime=#

Tab expansion works for ALIASes starting with / and for suits and for scripts=serverslist. You can use a trailing + to use a substring as the regexp (it also activates ignorecase) and as an AND to find a script or as a wildcard to just match multiple scripts; in the latter case, add a = to end the script part and expand possible serversfiles for the scripts matched. If you do not like the normal working of tab expansion (that trims up to the first dot, thus not showing you full script names), use a single plus as the parameter, then double-tab. 


=head2 Script Arguments

You can define arguments for your inline scripts. 

./evidencer os.show.boottime=# -a CET

Multiple arguments require multiple `-a` or you can use -- for ease:

./evidencer os.show.boottime=# -a arg1 -a arg2

./evidencer os.show.boottime=# -a 'arg1 arg2'

./evidencer os.show.boottime=# -- arg1 arg2

Note: Mixing multiple scripts means they all get these same paramters (if they use them)

=head1 LICENSE AND COPYRIGHT

This software is released under the Unlicense statement.
It is free and unencumbered software released into the public domain.
If you don't know what that means visit L<https://unlicense.org/>.

=head1 DEPENDENCIES

Evidencer is only an orchestrator. It needs a commandline remote execution tool. You can use ssh-batch (recommended) or Rundeer to actually perform the remote connections.

=head1 USAGE

./evidencer [opts] [suit:][script]=[serversfile]@regexp [-- <args>]

You need: scripts, serversfiles and a configured ssh-batch.

Short help: ./evidencer -h

Long help:  ./evidencer --man [-F]

=cut
